<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="http://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>No title</title>
    <meta content="TeXmacs 1.99.9" name="generator"></meta>
    <link href="http://www.texmacs.org/css/tmdoc.css" type="text/css" rel="stylesheet"></link>
    <script src="http://www.texmacs.org/javascript/texmacs_functions.js" language="javascript"></script>
  </head>
  <body>
    <div class="tmdoc-body">
      <table class="title-block">
        <tr>
          <td><table class="title-block">
            <tr>
              <td><font size="+3"><b>Programming in Fortran</b></font></td>
            </tr>
          </table><p style="margin-top: 1em; margin-bottom: 1em">
            <div class="compact-block">
              <table class="title-block">
                <tr>
                  <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                    <span style="margin-left: 0pt"></span>
                    <table style="display: inline; vertical-align: -0.55em">
                      <tbody><tr>
                        <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                          <p>
                            <class style="font-variant: small-caps">Youjun Hu</class>
                          </p>
                        </center></td>
                      </tr></tbody>
                    </table>
                  </p><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                    <span style="margin-left: 0pt"></span>
                    <table style="display: inline; vertical-align: -0.55em">
                      <tbody><tr>
                        <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                          <p>
                            Institute of Plasma Physics, Chinese Academy of
                            Sciences
                          </p>
                          <p>
                            Email: yjhu@ipp.cas.cn
                          </p>
                        </center></td>
                      </tr></tbody>
                    </table>
                  </p></td>
                </tr>
              </table>
            </div>
          </p></td>
        </tr>
      </table>
      <div style="margin-left: 60px">
        <div style="margin-right: 60px">
          <p>
            <font size="-1"><table style="width: 100%">
              <tbody><tr>
                <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
                  As a computational physicist using Fortran for decades, I
                  summarize what I know about Fortran and what features are
                  frequently used in practical programming.
                </p></td>
              </tr></tbody>
            </table></font>
          </p>
        </div>
      </div>
      <h2 id="auto-1">1.<span style="margin-left: 1em"></span>Why Fortran?</h2>
      <p>
        Fortran is a language tailored to the specific task of numerical
        computation. Most programming languages will have a flavor of Fortran
        if they are used to perform numerical computation. Fundamental support
        for multi-dimensional arrays in Fortran makes it convenient to write
        numerical programs, in which arrays are often the only data structure
        needed. Practical reasons why a computational physicist should learn
        Fortran include (1) Fortran is dominant in parallel computing (only C
        can compete with Fortran in this regard since MPI only supports C and
        Fortran). Fortran programs are using most of the resources of the
        largest supercomputers in the world. This is a strong indication that
        Fortran is dominant in the high performance computing area; (2)
        Fortran is still the most widely used programming language in the
        computational physics community so that one can not totally avoid
        reading or revising Fortran codes if one wants to communicate with
        people in the computational physics community.
      </p>
      <p>
        
      </p>
      <h2 id="auto-2">2.<span style="margin-left: 1em"></span>Compiler options help find bugs</h2>
      <p>
        Compilers are our friends, helping us find bugs earlier.
      </p>
      <p>
        For debug purpose, I primarily use open source compiler
        <code>gfortran</code>. The compiler options mentioned below will be
        for <code>gfortran</code> by default. The following are some useful
        <code>gfortran</code> compiler options that can help find bugs:
      </p>
      <p>
        <code>-std=f2008 -fcheck=all -Wall  -Wextra -fbounds-check</code>
        <code>-fimplicit-none</code>
      </p>
      <h2 id="auto-3">3.<span style="margin-left: 1em"></span>Basic syntax</h2>
      <p>
        Fortran is case-insensitive (this is different from most popular
        languages).
      </p>
      <p>
        Use either newline or semicolon to complete an statement (this is
        different from C which neglects newline). For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
int i
real j</pre>
      <p>
        is equivalent to
      </p>
      <pre class="verbatim" xml:space="preserve">
int i; real j</pre>
      <p>
        Use exclamation mark (<code>!</code>) for one line comment, which
        tells the compiler to discard everything from where the mark is found
        up to the end of the same line. Fortran does not have a keyword for
        defining block comment (multi-line comment) similar to C (<code>/*
        */</code>).
      </p>
      <h2 id="auto-4">4.<span style="margin-left: 1em"></span>Program units</h2>
      <p>
        The recommended way of organizing Fortran code is to use only two top
        units: <code>program</code> and <code>module</code>. And place
        <code>function</code>/<code>subroutine</code> in <code>modules</code>,
        which makes the full interfaces of the procedures available to a
        calling unit and thus makes it possible for compilers to check
        argument match at compiling time. This helps to find all bugs related
        to argument mismatch before actually running the code.
      </p>
      <h3 id="auto-5">4.1.<span style="margin-left: 1em"></span>Main program</h3>
      <pre class="verbatim" xml:space="preserve">
program your_name
  use your_modules
  implicit none
  real :: x
  x = 1.0 !assignment, this is a comment
  call some_subroutine
end program your_name</pre>
      <h3 id="auto-6">4.2.<span style="margin-left: 1em"></span>Functions and subroutines</h3>
      <p>
        Define subroutines:
      </p>
      <pre class="verbatim" xml:space="preserve">
subroutine p(arg1, arg2, more_arguments)
  some codes here
end subroutine p</pre>
      <p>
        Define functions:
      </p>
      <pre class="verbatim" xml:space="preserve">
function myfunc(arg1, arg2, more_arguments) result (myval)
  some codes here
end function myfunc</pre>
      <p>
        Use keyword <code>call</code> to invoke a subroutine:
      </p>
      <pre class="verbatim" xml:space="preserve">
call p(arg1, arg2, more_arguments)</pre>
      <p>
        Functions can be used in all expressions, e.g.,
      </p>
      <pre class="verbatim" xml:space="preserve">
a = myfunc(1,2)*1.0</pre>
      <p>
        Fortran pass arguments by reference (not by values). A subroutine or
        function knows the <strong>memory location</strong> of the actual
        arguments passed to them via the argument list. Generally no copying
        in and copying out of an array, but sometimes, copying in and copying
        out may be involved.
      </p>
      <h3 id="auto-7">4.3.<span style="margin-left: 1em"></span>Module</h3>
      <p>
        A module contains specifications and definitions that can be accessed
        from other program units. These definitions include data object
        definitions, namelist groups, derived-type definitions, procedure
        definitions, and procedure interface blocks. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
module mod_name
  use some_module
  implicit none
  real:: x
contains !the following must be subroutine/function
  subroutine p(arg1,&hellip;)
     some_codes_here
  end subroutine p
end module mod_name</pre>
      <p>
        As mentioned above, placing
        <code>function</code>/<code>subroutine</code> in <code>modules</code>
        (by using keyword <code>contains</code>) can make the full interfaces
        of the procedures available to a calling unit and thus makes it
        possible for compilers to check argument match at compiling time. This
        helps to find all bugs related to argument mismatch before actually
        running the code.
      </p>
      <p>
        All variables in a modules are assumed by most fortran compilers to
        have <code>save</code> attribute, but this is not required by the
        fortran standard. One way to make sure that all variables in a module
        retain their values throughout the runtime is to <code>use</code> that
        module in the main program, so that the module never goes out of scope
        and thus the values of the variables are retained throughout the
        runtime.
      </p>
      <h2 id="auto-8">5.<span style="margin-left: 1em"></span>Control flow</h2>
      <h3 id="auto-9">5.1.<span style="margin-left: 1em"></span><code>if</code> construct</h3>
      <pre class="verbatim" xml:space="preserve">
if (logical_expression1) then
   some_codes
elseif (logical_expression2) then
   some_codes
else
   some_codes
endif</pre>
      <p>
        where <code>elseif</code> and <code>else</code> clauses can be absent.
        A single branch <code>if</code> construct can be simplified as
      </p>
      <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve">if (logical expr)  one_statement</pre></pre>
      <p>
        Table <a href="#19-5-18-1">1</a> summarizes the relation operators and logical
        operators used in forming logical expressions:
      </p>
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline; vertical-align: -5.5em">
            <tbody><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">Operator</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid">Syntax 1</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid">Syntax 2</td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Equals</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a == b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .eq. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Not equals</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a /= b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .ne. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a &lt;  b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .lt. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than or equal to</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a &lt;= b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .le. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a &gt;<span style="margin-left: 1em"></span>b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .gt. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than or equal to</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a &gt;= b</code></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>a .ge. b</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Logical and</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>c .and. d</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Logical or</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>c .or. d</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Logical negation</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"></td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>.not. c</code></td>
            </tr></tbody>
          </table></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><p>
            <font size="-1"><p>
              <b>Table 1. </b><a id="auto-10"></a><a id="19-5-18-1"></a>Relation and logical
              operators in Fortran. Here <code>a</code> and <code>b</code> are
              of number type; <code>c</code> and <code>d</code> are of logical
              type.
            </p></font>
          </p></td>
        </tr></tbody>
      </table>
      <h3 id="auto-11">5.2.<span style="margin-left: 1em"></span>Loop structure</h3>
      <p>
        Fortran <code>Do</code> loop:
      </p>
      <pre class="verbatim" xml:space="preserve">
do i = nstart, nfinal, stride
   print *, 'i=', i
enddo</pre>
      <p>
        If you change the value of the loop index <code>i</code> inside the
        above loop structure, e.g. <code>i=i+1</code>, the compiler will
        complain:
      </p>
      <pre class="verbatim" xml:space="preserve">
Error: Variable 'i' at (1) cannot be redefined inside loop beginning at (2)</pre>
      <p>
        The above loop is similar to the <code>for</code> loop in C. For
        comparison, consider the following <code>for</code> loop of C:
      </p>
      <pre class="verbatim" xml:space="preserve">
  for(j=0;j&lt;10;j=j+1){
    printf(&quot;hello,%d\n&quot;,j);
    j=j+1;  }</pre>
      <p>
        where we also modify the value of loop index variable <code>j</code>
        inside the loop and this is allowed by C compilers. This comparison
        indicates that C is flexible and, as a side effect, more prone to
        possible bugs.
      </p>
      <p>
        Another loop structure using <code>while</code>:
      </p>
      <pre class="verbatim" xml:space="preserve">
do while(i&lt;10)
   write(*,*) 'i=',i
   i=i+1
enddo</pre>
      <p>
        The above <code>while</code> loop can also be implemented by using
        <code>if</code> and <code>goto</code>:
      </p>
      <pre class="verbatim" xml:space="preserve">
10 if (i&lt;10) then
   write(*,*) 'i=',i
   i=i+1
   goto 10
endif</pre>
      <p>
        The <code>while</code> loop can also be implemented by using
        <code>do</code> and <code>exit</code>:
      </p>
      <pre class="verbatim" xml:space="preserve">
do
   write(*,*) 'i=',i
   i=i+1
   if(i&gt;=10) exit
enddo</pre>
      <p>
        Here the <code>exit</code> statement will transfer control outside the
        <code>do</code> loop before the <code>enddo</code> is reached. After
        an <code>exit</code> statement has been executed, control is passed to
        the first statement after the loop. In passing, we note that there is
        a <code>cycle</code> statement that transfer control back to the
        beginning of the loop to allow the next iteration of the loop to
        begin.
      </p>
      <h2 id="auto-12">6.<span style="margin-left: 1em"></span>Basic data type</h2>
      <p>
        Fortran is a statically typed language, which means that the type of
        values that a variable can take is fixed at compile time and does not
        change during runtime. Fortran does not have the type inference
        capability available in some languages such as haskell, which means
        that we need to manually declare the type of all variables used in a
        program. The <code>implicit</code> rule that enables us to omit type
        declaration is &ldquo;syntactic sugar&rdquo; that we should avoid
        using in practice because it is bug-prone. To totally avoid the
        problematic &ldquo;implicit rules&rdquo; of fortran, using either
        <code>implicit none</code> or the compiler option
        <code>-fimplicit-none</code>, or using both for safety.
      </p>
      <p>
        Fortran has five basic data types, namely <code>integer</code>,
        <code>real</code>, <code>complex</code>, <code>logical</code> and
        <code>character</code>.
      </p>
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline; vertical-align: -3.3em">
            <tbody><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">Type</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid">Example values</td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">integer</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>1</code>, <code>0</code>,  <code>-2</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">real</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>1.25</code>, 2.1e8</td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">complex</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>(1.0, 2.0)</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">character</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"> <code>&ldquo;hello&rdquo;</code></td>
            </tr><tr>
              <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">logical</td>
              <td style="border-right: 1px solid; border-bottom: 1px solid"><code>.true.</code> <code>.false.</code></td>
            </tr></tbody>
          </table><p>
            
          </p></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><p>
            <font size="-1"><p>
              <b>Table 2. </b><a id="auto-13"></a>Built-in types of Fortran.
            </p></font>
          </p></td>
        </tr></tbody>
      </table>
      <p>
        Each data type has some attributes that can be further specified. For
        example, the length of a <code>character</code> variable is an
        attribute, which can be specified by using
      </p>
      <pre class="verbatim" xml:space="preserve">
character (len = 40) :: name </pre>
      <p>
        Without specifying the value of <code>len</code> parameter, the length
        of the variable is default to one.
      </p>
      <p>
        To specify the number of bytes for storing a <code>real</code>
        variable, we can use the <code>kind</code> parameter:
      </p>
      <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve"><code>real(kind=4) :: xs    ! 4  byte float
real(kind=8) :: xd    ! 8  byte float
real(kind=16) :: xq   ! 16 byte float</code></pre></pre>
      <p>
        However the meaning of the value of the <code>kind</code> parameter
        depends on the compiler. For example, some compilers may use the
        following scheme:
      </p>
      <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve"><code>real(kin=1) :: xs    ! 4  byte float
real(kind=2) :: xd   ! 8  byte float
real(kind=3) :: xq   ! 16 byte float</code></pre></pre>
      <p>
        I used to use
      </p>
      <pre class="verbatim" xml:space="preserve">
integer,parameter:: p_=kind(1.0d0) !return the kind value of a double precison constant
real(kind=p_) :: xd !use this value as the kind value</pre>
      <p>
        to define a double-precision variable (8 byte float). However, a more
        convenient way is NOT to specify the <code>kind</code> value of
        <code>real</code> variable in source code and use compiler options to
        specify the precision we want. For example, we write in the code:
        <code>real :: abc</code> and then compile the code by using the
        compiling option <code>-fdefault-real-8</code> (for
        <code>gfortran</code>) to specify a 8 byte float number. For
        <code>ifort</code>, the corresponding option is <code>-r8</code>.
      </p>
      <h2 id="auto-14">7.<span style="margin-left: 1em"></span>Array data structure</h2>
      <p>
        Scientific computing often deals with simple data structures with
        homogeneous elements, such as arrays, which are often the only data
        structure used in a numerical code. This makes derived types not so
        frequently needed. We first discuss arrays. Derived types are
        discussed later.
      </p>
      <p>
        Use <code>dimension</code> to declare arrays. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
real, dimension(0:2, 1:4, -1:3) :: A</pre>
      <p>
        defines a <code>real</code>-type array <code>A</code> with
        <strong>dimensionality</strong> being 3; the <strong>lower
        bound</strong> and <strong>upper bound</strong> of the 1st dimension
        are <code>0</code> and <code>2</code>, respectively; the
        <strong>extent</strong> along each dimension is equal to
        <code>upper_bound-lower_bound+1</code>, and for this case, is 3, 4,
        and 5, respectively. The dimensionality of an array is often called as
        &ldquo;<strong>rank</strong>&rdquo; in Fortran (although this name can
        be confused with the rank of a matrix in linear algebra, which
        corresponds to the maximal number of linearly independent columns of a
        matrix).
      </p>
      <p>
        The combination of the <strong>rank</strong> and corresponding
        <strong>extents</strong>, is called the <strong>shape</strong> of an
        array. In the above case the shape of the array is
        <code>(3,4,5)</code>. Two arrays are conforming with each other if
        they have the same shape.
      </p>
      <p>
        The following is a shortcut of defining an array (which omits the
        <code>dimension</code> keyword):
      </p>
      <pre class="verbatim" xml:space="preserve">
real :: A(0:2, 1:4, 2:6)</pre>
      <p>
        We need specify <strong>bounds</strong> in each dimension in order to
        completely specify a multidimensional array. If we do not specify the
        <strong>lower bound</strong> of the array, lower bound of array in
        Fortran is by default 1. The following declaration:
      </p>
      <pre class="verbatim" xml:space="preserve">
real :: B(1:3, 1:4, 1:6)</pre>
      <p>
        can be simplified as
      </p>
      <pre class="verbatim" xml:space="preserve">
real :: B(3, 4, 6)</pre>
      <p>
        In summary:
      </p>
      <ul>
        <li>
          <p>
            <strong>Rank</strong> is the number of dimensionality of an array
          </p>
        </li>
        <li>
          <p>
            <strong>Extent</strong> is the number of elements along a
            dimension
          </p>
        </li>
        <li>
          <p>
            <strong>Bound</strong> is the upper or lower index along a
            dimension
          </p>
        </li>
        <li>
          <p>
            <strong>Shape</strong> is the combination of <strong>rank</strong>
            and <strong>extents</strong>.
          </p>
        </li>
      </ul>
      <h3 id="auto-15">7.1.<span style="margin-left: 1em"></span>access array elements</h3>
      <p>
        Using index to access single element of an array. For example
      </p>
      <pre class="verbatim" xml:space="preserve">
B(1,2,1) = 1.0</pre>
      <p>
        Use the index range (start:end) to access multiple elements of an
        array (sub-array or array-slice). For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
write(*,*) B(1:2, 1:3, 3)</pre>
      <p>
        When referring to an array slice, both lower bound and upper bound can
        be omitted and they defaul to the declared array bounds . For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
write(*,*) B(:, :, 3)</pre>
      <h3 id="auto-16">7.2.<span style="margin-left: 1em"></span>Memory layout of multi-dimensional
      array</h3>
      <p>
        Since memory is laid out in one-dimension (each location has a single
        address index, not a set of indices), a compiler must decide how to
        map multi-dimensional arrays to memory locations. Different language
        use different conventions. In Fortran, arrays are stored &ldquo;by
        column&rdquo; in memory, which means putting each column of a 2D
        matrix in contiguous memory, as is illustrated in Fig. <a href="#19-5-18-p3">1</a>.
      </p>
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><img src="fortran-1.png" width="50%"></img></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><p>
            <font size="-1"><p>
              <b>Figure 1. </b><a id="auto-17"></a><a id="19-5-18-p3"></a>Fortran arrays are stored
              in memory &ldquo;by column&rdquo;. This layout is often called
              &ldquo;column-major order&rdquo;. As a comparison, C and Python
              use the &ldquo;row-major order&rdquo; layout, which puts each
              row of a matrix in contiguous memory.
            </p></font>
          </p></td>
        </tr></tbody>
      </table>
      <p>
        The above illustration is for 2D array. It is obvious how to
        generalize the &ldquo;column-major order&rdquo; layout to higher
        dimensional arrays: when traversing memory continuously, the first
        index of an array is the fastest changing, the second index is the
        second fastest changing, and so on.
      </p>
      <p>
        Why do we care the memory layout of an array?
      </p>
      <p>
        Firstly, knowing the layout enables us to calculate the memory offset
        of an array element. For example, for an array declared with
        <code>real(kind=8) :: a(m,n)</code>, the memory distance of an element
        <code>a(i,j)</code> from <code>a(1,1)</code> is [<var>m</var>
        <var>&times;</var>(<var>j</var> - 1) + <var>i</var> -
        1]<var>&times;</var>8byte if the layout is the column-major order. The
        distance would be [<var>n</var><var>&times;</var>(<var>i</var> - 1) +
        <var>j</var> - 1]<var>&times;</var>8byte if the layout was the
        row-major order.
      </p>
      <p>
        Secondly, the array layout is important to CPU cache and thus to code
        performance. A CPU views the memory as in 1D layout. When a CPU
        fetches an element from memory to operate on, it will guess that
        future operations may need some elements near that memory location.
        Therefore, a CPU will load a contiguous memory block near that
        location to CPU cache in order to make it comparatively quick to
        access elements potentially needed in future operations.
      </p>
      <p>
        Thirdly,  <strong>vectorized instructions</strong> of modern CPUs also
        requires consecutive access. (The vector processing can either be done
        with intrinsics, syntax hints of a Language, or by relying on the
        compiler's auto-vectorizer.)
      </p>
      <p>
        So, to get good code performance, always traverse data in the order
        they are laid out in memory.
      </p>
      <p>
        Layout of multi-dimensional arrays in memory is just a logical
        abstraction of the 1D linear memory. Different choices of layout can
        be simply considered as personal preference of the designers of a
        language. The personal preference of a language designer is related to
        the data structure and the type of operation on the data frequently
        used in his/her routine work. If we try, we can always find some
        reasons why a language prefers one layout over the another. For
        Fortran, I believe the reason is related to multiplication of a matrix
        with a vector, which can be arranged as
      </p>
      <p>
        <img src="fortran-2.png" width="90%"></img>
      </p>
      <p>
        In this form, it is an operation over individual columns of the
        matrix. Then it is beneficial to store a column in contiguous memory.
      </p>
      <p>
        For C and Python, which choose the &ldquo;row-major order&rdquo;
        layout, I believe the reason is related to the view that a
        multi-dimensional array is considered as a nested 1D array. Using
        Python list as an example:
      </p>
      <pre class="verbatim" xml:space="preserve">
In [3]: mylist = [[1,2,3], [4,5,6]]</pre>
      <p>
        which is a nested list corresponding a 2<var>&times;</var>3 matrix.
        Since the first row of the matrix corresponds to a 1D sub-list
        <code>mylist[0]</code>, it is natural to store these elements in
        contiguous memory (list elements are not necessary in continuous
        memory, here we assume that a 1D list is a 1D array).
      </p>
      <h3 id="auto-18">7.3.<span style="margin-left: 1em"></span>performance improvement due to the
      spatial locality in memory access patterns</h3>
      <p>
        Let us see a real example in Fortran, which clearly demonstrates the
        performance improvement thanks to the spatial locality in memory
        access patterns:
      </p>
      <pre class="verbatim" xml:space="preserve">
program main
  implicit none
  integer, parameter:: m=10000, n=30000
  real :: a(m,n), b(n), c1(m), c2(m)
  integer :: i, j
  real:: tarray(3) !record the cputime
  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  call cpu_time(tarray(1)) !f95 intrinsic subroutine returning the cpu clock

  c1=0.0
  do i=1,m !switching the two loops can improve the efficiency
     do j=1,n
        c1(i)=c1(i)+a(i,j)*b(j)
     enddo
  enddo
  call cpu_time(tarray(2))
  write (*,*) 'CPU time used (seconds) in inefficent algorithm', tarray(2)-tarray(1)

  c2=0.0
  do j=1,n
     c2(:)=c2(:)+a(:,j)*b(j)
  enddo
  call cpu_time(tarray(3))
  write (*,*) 'CPU time used (seconds) in efficient algorithm', tarray(3)-tarray(2)
end program main</pre>
      <p>
        The above code multiplies a matrix by a vector. Two methods are
        implemented, one is the naive way, another is using operation over
        individual columns of the matrix, as discussed above. Compile and run
        the code:
      </p>
      <pre class="verbatim" xml:space="preserve">
$ gfortran  c_r.f90  &amp;&amp; ./a.out 
 CPU time used (seconds) in inefficent algorithm   1.08469510    
 CPU time used (seconds) in efficient algorithm  0.208189011  </pre>
      <p>
        There is a factor of 5 performance gain due to the spatial locality in
        memory access patterns. In this example, the spatial locality help
        both cache and vectorized instructions, since we use Fortran array
        slice syntax, which usually enables vector processing. In the naive
        method, if we switch the order of the two loops, then we obtain
        spatial locality in memory access patterns, but the vector processing
        may not be enabled because we do not provide sufficient syntax hints
        to the compiler. In this case, the result is as follows:
      </p>
      <pre class="verbatim" xml:space="preserve">
$ gfortran  c_r.f90  &amp;&amp; ./a.out 
 CPU time used (seconds) in inefficent algorithm  0.621351004    
 CPU time used (seconds) in efficient algorithm  0.207148075  </pre>
      <p>
        The performance of the naive method improves but still 3 factor slower
        than the vectorized version. Let us add <code>-O3</code> optimization,
        which may try to vectorize any codes than can be vectorized. The
        result is as follows:
      </p>
      <pre class="verbatim" xml:space="preserve">
$ gfortran -O3 c_r.f90  &amp;&amp; ./a.out                                                         
CPU time used (seconds) in inefficent algorithm   7.00249672E-02
CPU time used (seconds) in efficient algorithm   7.00830221E-02</pre>
      <p>
        Finally, we obtain the same performance.
      </p>
      <p>
        In passing, I would like to mention another important tip that can
        improve spatial locality of memory access and hence code performance:
        avoid using fine-grained derived datatypes or many small arrays,
        instead, try to gather them together into an array to improve locality
        in memory access. To demonstrate this, let us consider a famous
        example in particle simulations, where each particle has three spatial
        coordinates, say <var>x</var>,<var>y</var>,<var>z</var>. The intuitive
        method would use three arrays, <code>x(n),y(n),z(n)</code>, to store
        these coordinates for each particle, where <code>n</code> is the total
        particle number, which is usual a large number, e.g. 10<sup>6</sup>.
        The jth elements of the three arrays will be frequently used together
        in a computation, for example <code>s=x(j)**2+y(j)**2+z(j)**2</code>.
        In this case, a better way of organizing the data is to combine the
        three arrays into one array, e.g., <code>cor(3,n)</code>, with the
        first index of the 1st dimension corresponding to <var>x</var>, second
        index to <var>y</var>, and third to <var>z</var>. Then the above
        expression would be
        <code>s=cor(1,j)**2+cor(2,j)**2+cor(3,j)**2</code>, where the three
        elements are contiguous in memory and thus can help the cache and
        speedup the computation.
      </p>
      <h3 id="auto-19">7.4.<span style="margin-left: 1em"></span>Static arrays</h3>
      <p>
        We define static arrays as arrays whose shape and bounds are known at
        compile time, i.e., fully-declared-at-compile-time arrays.
      </p>
      <p>
        If a static array is declared in a local scope, typically in a
        <code>subroutine/function</code>, its values are not retained between
        different calls to the <code>subroutine/function</code> (i.e., the
        array is automatically deallocated when the procedure returns, as
        automatic arrays (discussed later) would be). To retain the value, we
        can specify <code>save</code> attribute when declaring the array.
        Static arrays with <code>save</code> attribute are not allocated on
        the stack. They actually exist in neither the stack nor the heap. The
        are part of what's called the &ldquo;data segment&rdquo;. Similar
        situation applies to the <code>static</code> variables in
        <code>C</code>.
      </p>
      <p>
        Static arrays without <code>save</code> attribute are usually
        allocated on stack. However the size of stack is limited, large arrays
        have to be allocated in heap in order to avoid the stack overflow
        (this can be achieved by declaring an array as allocatable and
        allocating it manually, which usually imply that the allocation
        happens on the heap. However the Fortran standard has no concept of
        stack and heap, so this will be implementation (i.e. compiler)
        dependent.)
      </p>
      <h3 id="auto-20">7.5.<span style="margin-left: 1em"></span>dynamic arrays</h3>
      <p>
        We define a dynamic array as an array whose extent along each
        dimension is not fully declared when they are defined. Partially
        declared extent includes two cases: (1) the extent is not specified,
        which corresponds to an allocatable array or (2) the extent is
        specified with variables, which corresponds to an automatic array.
      </p>
      <p>
        The rank of a dynamic array is always known at compile time since the
        notation of array declariation does not allow un-specified rank.
      </p>
      <p>
        Dynamic arrays are created at particular run times (by programmers
        explicitly or by compilers implicitly) with sizes determined by
        computed (or input) values. Fortran 90 has three varieties of dynamic
        arrays, namely:
      </p>
      <ul>
        <li>
          <p>
            allocatable arrays
          </p>
        </li>
        <li>
          <p>
            automatic arrays
          </p>
        </li>
        <li>
          <p>
            pointer arrays
          </p>
        </li>
      </ul>
      <p>
        In high performance computing (HPC), it is usually recommended that we
        avoid using pointer arrays because they may prevent possible
        optimization by the compiler.
      </p>
      <h4 id="auto-21">7.5.1.<span style="margin-left: 1em"></span>Allocatable arrays</h4>
      <p>
        Allocatable arrays are arrays whose bounds along each dimension are
        unknown at compile time (the rank is known), with their
        creation/deletion and their bounds/size being controlled by
        programmers at runtime. Use keyword <code>allocatable</code> to
        declare a allocatable array. In this case, only the rank needs to be
        specified. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
real, dimension(:,:), allocatable :: A</pre>
      <p>
        To allocate a dynamic array:
      </p>
      <pre class="verbatim" xml:space="preserve">
allocate(A(-1:3,4))</pre>
      <p>
        [Besides using <code>allocate</code> statement, there is another way
        in which an allocatable array will get (re-)allocated: assigning an
        array or array slice to an allocatable array name (rather than its
        slice). For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
real, allocatable :: A(:,:)
real              :: B(3,4), C(5,6)
A = B  !A will get allocated, with the same shape and bounds as B
write(*,*) size(A,1), size(A,2), lbound(A,1)
A = C  !A will be de-allocated and then re-allocated to the same shape and bounds as C
write(*,*) size(A,1), size(A,2), lbound(A,1)</pre>
      <p>
        This is informally called &ldquo;(re-)allocation on assignment&rdquo;,
        which makes dynamic arrays looks more like a variables in a
        dynamically typed language. However, there is overhead here because
        lots of checks/actions need to be done at runtime (e.g., is the
        allocatable array already allocated?, if allocated, is the shape and
        bounds are the same as the right-hand side array? if they differ, the
        allocated array will be de-allocated and then re-allocated to the same
        shape and bounds of the right-hand side).
      </p>
      <p>
        Therefore, I usually try to avoid using this kind of automatic
        (re-)allocation on assignment. One can always suppress the
        (re-)allocation checks/actions of an array by using an array section
        (rather than an array name) in an assignment:
      </p>
      <pre class="verbatim" xml:space="preserve">
A(:,:) = B</pre>
      <p>
        In this case, if the allocatable array <code>A</code> is not allocated
        or already allocated but its shape does not match <code>B</code>,
        runtime error will appear.]
      </p>
      <p>
        To de-allocate a dynamic array:
      </p>
      <pre class="verbatim" xml:space="preserve">
deallocate(A)</pre>
      <p>
        The creation and deletion of dynamic arrays are under full control of
        a programmer, with one exception that a dynamic array without
        <code>save</code> attribute will be automatically deleted if the
        declaration of the dynamic array goes out of scope. For example, an
        allocatable array without <code>save</code> attribute defined in a
        subroutine will be automatically deleted when the subroutine returns
        (i.e., the declaration of the allocatable array goes out of scope).
        The automatic deletion of dynamic array can be prevented by specifying
        <code>save</code> attribute when declaring the array. For most fortran
        compilers, dynamic arrays declared in a <code>module</code> are
        assumed to have <code>save</code> attribute by default. 
      </p>
      <h4 id="auto-22">7.5.2.<span style="margin-left: 1em"></span>Automatic arrays</h4>
      <p>
        An <strong>automatic array</strong> is a local array (not a dummy
        argument) of a <code>subroutine/function</code> and its definition
        involves variables whose values are unknown at compile time. Automatic
        arrays can not be delcared in <code>program</code> or
        <code>module</code> units.
      </p>
      <p>
        This kind of arrays are called automatic arrays because their
        allocation (usually on stack) and de-allocation are automatically
        handled without explicit instructions from programmers. Specifically,
        a automatic array will be de-allocated automatically when it goes out
        of scope. We can not use <code>save</code> attribute to an automatic
        array. Otherwise, we will get compiling errors such as follows:
      </p>
      <pre class="verbatim" xml:space="preserve">
Error: Automatic object cannot have the SAVE attribute</pre>
      <p>
        If we really want to have a persitent arary, we should use
        <strong>allocatable arrays</strong> or <strong>static arrays</strong>,
        for which a <code>save</code> attribute is allowed. Note in passing
        that an allocatable array (not a dummy argument) defined in a
        <code>subroutine/function</code> without the <code>save</code>
        attribute will be automatically deallocated upon
        <code>subroutine/function</code> return, which is the same as an
        automatic array. (As a general rule, if an  array/scalar is local to
        the routine, memory is allocated on entry to the routine and
        deallocated on return to the caller.)
      </p>
      <p>
        Automatic arrays are usually allocated on the stack whereas
        allocatable arrays are allocated on the heap. But this behavior is not
        specified in the Fortran standard, and can depend on specific
        implementations. Does this difference between automatic arrays and
        allocatable arrays results in any difference in performance? (need to
        be examined)
      </p>
      <p>
        Since automatic arrays can have different sizes between different
        calling to the <code>subroutine/function</code>, they are a kind of
        adjustable arrays.
      </p>
      <p>
        In summary, automatic arrays are <strong>local</strong> arrays
        declared in a <code>subroutine/function/block</code> with definition
        involving variables whose values are unknown at compile time. 
        Automatic arrays are not allowed to have the <code>save</code>
        attribute.
      </p>
      <p>
        The specification of an automatic array is allowed to contain function
        calls, which can be either built-in or user-defined functions, with
        the only requirement that the functions must be <code>pure</code>,
        i.e., no side effects. One often used function in this case is the
        built-in inquiry function <code>size</code>, which is used to query
        the size of other arrays, and then the returned value is used in
        defining the automatic array. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
real :: myarray(size(a,1), size(a,2))</pre>
      <p>
        Local non-constant variables in a subroutine are not allowed to appear
        in the specification expression of automatic arrays. The reason is
        that an automatic arry needes to be allocated at the begining of the
        procedure, but a local variable does not have a defined value just on
        entry to the routine. Even if we initialize the value of the local
        variable when declaring it, this value is available only when the
        first executable statment in the procedure is executed because
        initialization is an assignment (an executable statement), which is
        not a pure function.
      </p>
      <p>
        The specification expression of automatic arrys is allowed to use
        dummy arguments of the procedure and variables from modules (including
        its host module if the subroutine is contained in a module).
      </p>
      <p>
        These rules are also applicable to the dummy argument arrays discussed
        in Sec. <a href="#19-5-25-1">7.6</a>.
      </p>
      <p>
        
      </p>
      <h3 id="auto-23"><a id="19-5-25-1"></a>7.6.<span style="margin-left: 1em"></span>Dummy argument arrays</h3>
      <p>
        If a dummy argument of a procedure is declared as an array, then
        generally no array is actually allocated on entry to the procedure. It
        just refers to the actual argument arrays passed in from the calling
        unit. So dummy argument arrays are not new type of arrays, but the
        syntax of declaring them may be different from that of declaring
        static/automatic/allocatable arrays. And the syntax is used to
        determine what information of the actual argument array is passed in
        from the calling units. There are four syntaxes of declaring a dummy
        argument array:
      </p>
      <pre class="verbatim" xml:space="preserve">
real :: a(m,n) !explicit shape array
real :: b(m,*)   !assumed size array, not recomended now.
real :: c(2:,3:) !assumed shape array
real, allocatable :: d(:,:) !allocatable (dummy argument) array</pre>
      <p>
        Let us discuss these four types in turn.
      </p>
      <h4 id="auto-24">7.6.1.<span style="margin-left: 1em"></span>explicit shape array</h4>
      <p>
        In the first two cases, i.e., <code>explicit shape array</code> and
        <code>assumed size array</code>, usually just a pointer to the first
        element of the actual argument array is passed in. Since only a
        pointer is available with no stride being available, the compiler has
        to assume that the stride is 1, i.e., the array is contiguous in
        memory. If we pass an array slice that is not contiguous in memory to
        a dummy argument declared as an <code>explicit shape array/assumed
        size array</code>, a temporary array will be created and the data of
        the array slice is copied in (and copied out when the subroutine
        returns) in order to guarantee that the resulting array is contiguous
        in memory so that the subroutine is doing right to the actual argument
        array. For this case, <code>gfortran</code> will give the following
        warning:
      </p>
      <pre class="verbatim" xml:space="preserve">
Fortran runtime warning: An array temporary was created for argument 'a' of procedure 'p'</pre>
      <p>
        If the dummy array is declared as an explicit shape array, rank
        mismatch between actual array and dummy array is allowed. However,
        this kind of use is error prone. Most time we prefer that the actual
        and dummy array have the same shape.
      </p>
      <p>
        In the above example, the variables <code>m,n</code> appearing in the
        specification expression of the explicit shape array can be dummy
        argument variables or module variables, but can not be a local
        variable of the procedure. The following is an example of
        <strong>explicit array</strong>:
      </p>
      <pre class="verbatim" xml:space="preserve">
subroutine p(u,m)
 use some_module, only : n
 real :: u(m,n) !explicit shape array
end</pre>
      <p>
        A common bug when using explicit array is that the rank/extent/bound
        declared in a procedure are different from those of the actual
        argument array. As mentioned above, this mismatch is allowed by the
        compiler. If the mismatch is not intended by the programmer (i.e., the
        programmer made a mistake in the declaration), then the code usually
        will not work correctly.
      </p>
      <h4 id="auto-25">7.6.2.<span style="margin-left: 1em"></span>assumed size array</h4>
      <p>
        An <b>assumed-size array</b> is an array that is a dummy argument and
        has an asterisk as the upper bound of the last dimension:
      </p>
      <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve">subroutine p( A, B, C ) 
 Integer :: A(*), B(5, *) !lower-bound of the last dimension default to 1
 Integer :: C(0:1, 2:*) !explicitly specify the lower-bound of the last dimension
end</pre></pre>
      <p>
        The extent of the last dimension does not need to be specified because
        it is not needed (by the compiler) in calculating the memory address
        offset of an array element with respect to the first element. However,
        I prefer to use explicit-shape arrays over assumed-sized array since
        it is not a big deal to just omit a single bound. Omitting the last
        upper bound also makes bounds checking difficult since the last upper
        bound is not defined in the subroutine.
      </p>
      <h4 id="auto-26">7.6.3.<span style="margin-left: 1em"></span>assumed shape array</h4>
      <p>
        To declare an argument as an <code>assumed shape array</code>, we only
        need to specify the rank and the lower bounds along each dimension
        (lower bounds default to 1 if not specified). The upper bounds will be
        automatically inferred during runtime from the length in each
        dimension of the actual array passed in. The following are examples of
        <strong>assumed shape array</strong>:
      </p>
      <pre class="verbatim" xml:space="preserve">
subroutine p1(A, B)
 real :: A(0:,2:) !upper bounds will be inferred from the length of the actual array
 real :: B(:,:)   !lower bounds are not specified and are default to 1
end</pre>
      <p>
        For the third case, i.e., <code>assumed shape array</code>, an array
        descriptor structure will be passed in, which contains the pointer to
        the first element of the actual argument array plus information on the
        length of each dimension and stride.
      </p>
      <p>
        As is mentioned above, if the dummy array is declared as an explicit
        shape array and we pass in an array slice that is not contiguous in
        memory, an array temporary will be created and the data of the array
        slice is copied in and then copied out. On the other hand, if the
        dummy array is declared as an assumed shape array, no array temporary
        will be created. However, this does not mean the performance will be
        better than the case of using explicit shape array, where an temporary
        array is created and data be copied in and out. This is because the
        latter case can improve spatial locality in memory access pattern,
        although involving additional allocations and copying in and out
        operations. Therefore, which methods will win in terms of performance
        depends on specific applications.
      </p>
      <p>
        If the dummy array is declared as an assumed shape array, the compiler
        will check agreement between the the rank of actual array and dummy
        array, giving error information if they mismatch. This kind of
        mismatch is allowed if explicit shape array is used. However, this
        kind of use is error prone. Most time we prefer that the actual and
        dummy array have the same shape.
      </p>
      <p>
        In summary, assumed-shape arrays are dummy argument arrays where the
        extent of a dimension is inherited from the corresponding actual
        array. The dimensionality (i.e., rank) of the array is known and must
        be specified in the subroutine, for example, <code>a(:,:,:)</code>
        specifies that the rank is 3. If the actual array and the assumed
        shape array have different ranks, a compiler usually complains at
        compiling time, for example, <code>gfortran</code> raises the error
        information: <code>Rank mismatch in argument</code>.
      </p>
      <p>
        Summary 2: we have two choices in declaring a dummy array in a
        subroutine. One choice is to declare it as an <code>explicit shape
        array</code> (using formal argument variables, or modules, or
        constants to specify the shape of the array). Another choice is to
        define <code>assumed (implicit) shape array</code>, for which we
        specify only the rank and lower bound (the lower bound is 1 if not
        specified) of the array and we do not specify the length along each
        dimension. The unspecified information will be inferred automatically
        from the actual argument array during runtime.
      </p>
      <h4 id="auto-27">7.6.4.<span style="margin-left: 1em"></span>allocatable dummy argument array</h4>
      <p>
        For the fourth case, an dummy argument is declared as an allocatable
        array. In this case, the corresponding actual argument must also be an
        allocatable array, otherwise <code>gfortran</code> will raise
        <code>Error: Actual argument for &lsquo;a' must be ALLOCATABLE at
        (1).</code>
      </p>
      <p>
        The actual argument allocatable array passed in can be already
        allocated, or not allocated yet and it can be allocated in the
        subroutine. One can use inquiry function <code>allocated()</code> to
        get the allocation status of an allocatable array passed in.
      </p>
      <p>
        
      </p>
      <h2 id="auto-28">8.<span style="margin-left: 1em"></span>Pure function and subroutine</h2>
      <p>
        To define a pure function (functions with no side effects), we use the
        keyword <code>pure</code>. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
pure function f(x) result(z)
integer, intent(in):: x
integer :: z
z=x*2
end function f</pre>
      <p>
        All dummy argument variables of a pure function must be
        <code>intent(in)</code>. Pure subroutines can be defined in a similar
        way, except that the dummy argument variables can have
        <code>intent(out)</code>.
      </p>
      <p>
        Since pure procedures do not allow side effects (i.e., do not change
        the state of the outer world), the compiler will raise error if we try
        to modify the value of a variable of a <code>module</code> that is
        used in this procedure:
      </p>
      <pre class="verbatim" xml:space="preserve">
Error: Variable 'tmp' can not appear in a variable definition context (assignment) in PURE procedure</pre>
      <p>
        Fortran pure functions can use module variables as (invisible) input,
        which can change between function invocations. Therefore fortran pure
        functions can not guarantee &ldquo;same argument, same result&rdquo;.
        This is different from the pure function concept in funtional
        programming languages, e.g. Haskell, where &ldquo;same argument, same
        result&rdquo; is guaranteed.
      </p>
      <p>
        Local variables within the scope of a <code>pure</code> procedure
        cannot have the <code>save</code> attribute, which implies that they
        cannot be initialized when declared, or by a DATA statement.
      </p>
      <p>
        Any procedures that are invoked from a <code>pure</code> procedure
        must be <code>pure</code>. No external I/O operations may occur within
        a PURE procedure since these change the stae of the outer world, i.e.,
        side effects.
      </p>
      <h2 id="auto-29">9.<span style="margin-left: 1em"></span>Elemental function</h2>
      <p>
        <code>Elemental</code> functions are pure functions defined with a
        single scalar dummy argument and a scalar return value, but they can
        be invoked with arrays as actual arguments, in which case the function
        will be applied element-wise, with a conforming array return value.
        This kind of function is indicated with the <code>elemental</code>
        prefix. Since it is implied that an elemental function is also pure,
        the <code>pure</code> prefix is not necessary.
      </p>
      <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve">module test_mod
contains
  elemental real function square(x)
     real, intent(in) :: x
     square = x*x
  end function
end module</pre></pre>
      <p>
        Elemental subroutines may be defined in a similar way
        (<code>intent(out)</code> or <code>intent(inout)</code> arguments are
        allowed). The main benefit of elemental procedures is just for syntax
        convenience, it does not have semantics that lend themselves to
        effective parallelization.
      </p>
      <h2 id="auto-30">10.<span style="margin-left: 1em"></span>Variable scope and lifetime</h2>
      <p>
        Not all variables are accessible from all parts of our program, and
        not all variables exist for the same amount of time. Where a variable
        is accessible and how long it exists depend on how it is defined. We
        call the part of a program where a variable is accessible its
        <em>scope</em>, and the duration for which the variable exists its
        <em>lifetime</em>.
      </p>
      <h3 id="auto-31">10.1.<span style="margin-left: 1em"></span>Scope of variables: global and local
      variables</h3>
      <p>
        The scope of a variable, more accurately the scope of a naming binding
        (an association of a name to an entity) is the region of a computer
        program where the binding is valid: where the name can be used to
        refer to a value. Such a region is referred to as a scope block. In
        other parts of the program the name may refer to a different entity
        (it may have a different binding), or to nothing at all (it may be
        unbound).
      </p>
      <p>
        The scope of a binding is also known as the visibility of an entity.
        In other words, which parts of your program can see or use it. In
        practice, for most programming languages, &ldquo;part of a
        program&rdquo; refers to &ldquo;part of the source code&rdquo;, and is
        known as <b>lexical scope</b> (another kind of scope called <b>dynamic
        scope</b> will be discussed later). The lexical scope for a set of
        bindings in practice largely corresponds to a block, a function, or a
        file, depending on languages and types of entity.
      </p>
      <p>
        Unlike C/C++, Fortran before 2008 standard does not have source code
        blocks where new variables can be defined. Fortran 2008 introduces the
        keyword <code>block</code> to define blocks, where local variables can
        be declared. For examples, the following code defines two nested
        blocks in which local variables <code>res1</code> and
        <code>res2</code> are defined.
      </p>
      <pre class="verbatim" xml:space="preserve">
PROGRAM foo
implicit none
  INTEGER :: a
  a=3.0
  write(*,*) 'a=',a
  BLOCK            
    INTEGER :: res1
    res1 = a + 1
    write(*,*)  'res1=',res1
    BLOCK
      INTEGER :: res2
      res2 = res1 + 1
      write(*,*)  'res2=',res2,'res1=',res1
    ENDBLOCK
  ENDBLOCK
END PROGRAM foo    </pre>
      <p>
        In summary, the <code>block</code> creates its own name space.
      </p>
      <p>
        I use <code>block</code> to add temporary diagnostic codes to existing
        programs. Doing this way allow all temporary local variables to be
        gathered together near the diagnostic codes and thus easy to read and
        easy to remove. This is more convenient than adding and calling new
        external diagnostic subroutines. In passing, adding diagnostic
        internal subroutines using <code>contains</code> is as convenient as
        using <code>block</code> and may be more elegant.
      </p>
      <p>
        In C/C++, variables defined outside of all functions are global
        variables. Fortran does not have such kind of global variables. To
        pass information between subroutines, besides using subroutine
        parameter lists, one way is to use variables in a <code>module</code>
        which can be shared between subroutines.
      </p>
      <h3 id="auto-32">10.2.<span style="margin-left: 1em"></span>Local variables with <code>save</code>
      attribute</h3>
      <p>
        A local variable defined in a procedure can have the <code>save</code>
        attribute, which will make the local variable retain its value between
        different procedure calls. These variables are called persistent
        variables. For example:
      </p>
      <pre class="verbatim" xml:space="preserve">
function f()
integer, save :: i=1
i = i+1
print *, i
end function</pre>
      <p>
        However, for multiple-thread applications, this kind of local variable
        will be shared among different threads, which means that racing
        problem will appear if the procedure is called in multiple threads.
        Considering this situation, computer guys often say that this kind of
        local variables are &ldquo;thread unsafe&rdquo;.
      </p>
      <p>
        
      </p>
      <p>
        A local variables with <code>save</code> attribute is hidden input to
        the procedure in which the variable is defined.
      </p>
      <h3 id="auto-33">10.3.<span style="margin-left: 1em"></span>Lifetime of variables</h3>
      <p>
        Variables with <code>save</code> attribute will be alive from their
        creation to the end of the program, i.e., they are not automatically
        destroyed when they go out of scope. As a result, if the variables
        with <code>save</code> attribute is a local variable defined in a
        subroutine, then its value will be retained between different
        revocations of the subroutine. In contrast, local variables without
        <code>save</code> attribute will be automatically destroyed when they
        go out of scope. As a result, their values can not be retained between
        different revocations of the subroutine.
      </p>
      <p>
        
      </p>
      <h3 id="auto-34">10.4.<span style="margin-left: 1em"></span>Global variables</h3>
      <p>
        In C language, variables declared outside functions are global
        variables, which can be assessed from any functions. Fortran does not
        have this kind of global variables, but variables in
        <code>modules</code> are accessible to other program units if the
        modules are imported to that unit. In principle, a variable defined in
        a <code>module</code> is a local variable to that module, and will be
        destroyed when the program unit that uses the <code>module</code>
        returns. However, two situations (often appear in practice) can make
        the module variables not be destroyed during the entire runtime: (1)
        the <code>module</code> is used in the main program and thus never
        goes out of scope during the runtime, (2) <code>save</code> attribute
        is used for the variables in the <code>module</code>, so they retain
        their values. Most fortran compilers will treat variables defined in a
        <code>module</code> as with <code>save</code> attribute even if no
        <code>save</code> attribute is specified. But for safety, we should
        specify <code>save</code> attribute for variables in a
        <code>module</code> if we want their values to be retained when they
        go out of scope.
      </p>
      <p>
        The above practice makes <code>module</code> variables look like
        global variables. For this reason, we often simply say that modules
        define global data.
      </p>
      <p>
        Due to the global nature of <code>module</code> variables, they are
        shared across threads and are therefore thread-unsafe. To make an
        application thread-safe, we must declare the global data as
        THREADPRIVATE or THREADLOCAL.
      </p>
      <p>
        
      </p>
      <p>
        
      </p>
      <h2 id="auto-35">11.<span style="margin-left: 1em"></span>Tips for improving performance</h2>
      <p>
        New syntaxes in a language seldom benefit performance. That is,
        &ldquo;code with new syntax&rdquo; doesn't imply &ldquo;better
        compiler optimizations&quot;, and even F77 is a &ldquo;high
        level&rdquo; language. Efficient Fortran codes should stick to F77
        features at their core for high performance, most of newer features
        would usually result in less efficient executables. F90 and newer
        would be mainly useful for readablity, maintainability and
        extensibility of the code
      </p>
      <p>
        Do you have some strong evidence to support such statements?
      </p>
      <p>
        Well, yes, there is evidence for this strategy. I do not claim, that
        all newer features have a negative impact on performance, or that you
        should not use them at all. Just in the very kernel, the F77 style is
        generally a good guide to produce efficient code. (Staying away from
        pointer and target attributes, do not use fine-grained derived
        datatypes, there was even a time when array syntax statements are
        slower than explicit do-loops, though compilers seem to have much
        improved). I am actually using F2003 features heavily, my point is
        just in the very kernel, there is probably little benefit.
      </p>
      <p>
        Vectorization, if by this you mean the F90+ array syntax, is mostly a
        programmer convenience issue rather than allowing faster code. A
        competent compiler will vectorize the equivalent DO loop just as well.
      </p>
      <p>
        There is one major reason why Fortran 77 programs might be faster:
        Allocated arrays (Fortran 90) are much slower than
        declared-at-compile-time arrays. Both are not put at the same place in
        memory (stack vs heap). The difference in memory management of stack
        and heap in Fortran can change the performance. The Fortran standard
        has no concept of stack and heap, so this will be implementation (i.e.
        compiler) dependent.
      </p>
      <p>
        
      </p>
      <h2 id="auto-36">12.<span style="margin-left: 1em"></span>Coarray</h2>
      <h2 id="auto-37">13.<span style="margin-left: 1em"></span>Writing/reading files</h2>
      <p>
        After Fortran 2008, the recommended way of opening file is as follows:
      </p>
      <pre class="verbatim" xml:space="preserve">
integer :: myunit
open(newunit=myunit, file='myfile.txt')
write(myunit, *) 'hello world'   !use the unit number to write to the file</pre>
      <p>
        Here <code>newunit</code> is an <code>intent(out)</code> keyword
        argument, which returns an available unit number.
      </p>
      <h2 id="auto-38">Appendix A.<span style="margin-left: 1em"></span>Object-oriented programming in
      Fortran</h2>
      <p>
        Object-oriented programming style is not often used in numerical
        codes. Here I discuss this just for my curiosity.
      </p>
      <p>
        Fortran, the oldest high-level programming language, was designed and
        used mainly for the purpose of numerical computation. Although Fortran
        is also claimed as a general-purpose programming language, it lies
        behind other popular general-purpose Language, such as C/C++ and
        Python, in some aspects. One of these aspects is the supporting to the
        object-oriented programming.
      </p>
      <p>
        Why is the object-oriented programming not widely adopted in
        scientific computing? Scientific computing often deal with simple data
        structures with homogeneous elements, such as arrays, which are often
        the only data structure used in a numerical code. This makes derived
        types not so frequently needed. Derived types are generalization of
        arrays and can contain inhomogeneous elements, which provide a more
        powerful organizing capability than arrays. Classes in object-oriented
        programming are a special kind of derived types that have procedures
        bound to.
      </p>
      <p>
        Fortran's <code>module</code> can contain both data and procedures.
        But we can not use the name of a module to define an object. On the
        other hand, <code>module</code> can contain derived type definition
        and this derived type can be used to define an object. Therefore a
        Fortran <code>module</code> containing both derived type definitions
        and procedures can be used as the counterpart of <code>class</code> in
        object-oriented languages. However the binding between a derived type
        object and its procedures must be implemented manually by programmers
        before Fortran 2003. The following is a Fortran 95 example emulating
        object-oriented programming style.
      </p>
      <pre class="verbatim" xml:space="preserve">
module class_point
  implicit none
  type, public :: point
     real :: x
     real :: y
  end type point
contains
  function distance(this) result(z) !distance from origin
    type(point), intent(in) :: this
    real :: z
    z = sqrt((this%x)**2+(this%y)**2)
  end function distance

  subroutine add(this,another,my_sum) 
    type(point), intent(in) :: this, another
    type(point):: my_sum
    my_sum%x=this%x+another%x
    my_sum%y=this%y+another%y
  end subroutine add
  
  subroutine print_point(this)
    class(point), intent(in) :: this
    real :: tmp
    tmp = distance(this)  
    print *, 'Point: (x,y) = ', this%x, this%y, ' distance from orig = ', tmp
  end subroutine print_point
end module class_point

program point_test
  use class_point,only: point, distance,add, print_point
  implicit none
  type(point) :: p1,p2,p3    ! Declare variables of type point.
  p1 = point(3.0,4.0)   ! Use the implicit constructor
  call print_point(p1)       !pass the object to the procedure via a argument
  p2 = point(1.0,0.5)   ! Use the implicit constructor
  call add(p1,p2,p3)
  call print_point(p3)
end program point_test</pre>
      <p>
        The above is not real object-oriented programming because the
        procedures are not actually bound to the object. Fortran 2003 provides
        type-bound procedures: those procedures that appear in the definition
        of the derived type following the <code>contains</code> statement. The
        following is a revised version of the above program.
      </p>
      <pre class="verbatim" xml:space="preserve">
module class_point
  implicit none
  private !set the default as private
  type, public :: point
     real :: x
     real :: y
   contains
     procedure:: distance
     procedure:: printp
     procedure:: add
     procedure:: add_func
  end type point
contains
  function distance(this) result(z) !distance from origin
    class(point), intent(in) :: this
    real :: z
    z = sqrt((this%x)**2+(this%y)**2)
  end function distance

  subroutine add(this,another,my_sum) 
    class(point), intent(in) :: this, another
    class(point):: my_sum

    my_sum%x=this%x+another%x
    my_sum%y=this%y+another%y

  end subroutine add

  function add_func(this,another)  result(my_sum)
    class(point), intent(in) :: this 
    type(point), intent(in):: another
    type(point):: my_sum

    my_sum%x=this%x+another%x
    my_sum%y=this%y+another%y

  end function add_func

  subroutine printp(this)
    class(point), intent(in) :: this
    real :: tmp
    tmp = this%distance()  ! Call the type-bound function
    print *, 'Point: (x,y) = ', this%x, this%y, ' distance from orig = ', tmp
  end subroutine printp
end module class_point

program test
  use class_point
  implicit none
  type(point) :: p1,p2,p3     ! Declare a variable of type point.
  p1 = point(3.0,4.0)   !Use the implicit constructor
  call p1%printp         !Call the type-bound subroutine
  p2 = point(1.0,0.5)   ! Use the implicit constructor
  call p2%printp
  call p1%add(p2,p3)
  call p3%printp
print *, p1%add_func(p2)
end program test</pre>
      <p>
        Three things need to be noted. First, two <code>contains</code> appear
        here, one of which bounds the procedures names to the derived type and
        another is the same as the above, i.e., contains the definition of the
        procedures. Second, in the definition of the procedure, the first
        argument must be of the same type of the derived type and the
        declaration using the <code>class</code> keyword, instead of the
        <code>type</code> keyword. This a fundamental requirement for
        type-bound procedures. If declared using <code>type</code>, gfortran
        compiler would raise the following error: Non-polymorphic
        passed-object dummy argument. This is required by compilers to
        consider this procedure as a type-bound procedure rather than an
        ordinary one. Third, when calling the type-bound procedure, the object
        is passed to the procedure in the object-oriented way, e.g.,
        <code>p1%print_point</code> rather than <code>print_point(p1)</code>.
      </p>
      <p>
        
      </p>
      <p>
        Viktor K. Decyk's paper on this.
      </p>
      <p>
        The code which modifies a given data structure should be localized or
        confined to one location in the program and not spread,
        uncontrollably, throughout the program. This property is called an
        encapsulation. In a sense, it is a generalization of the familiar
        notion of a function or subroutine.
      </p>
      <p>
        http://www.cs.rpi.edu/~szymansk/OOF90/F90_Objects.html
      </p>
      <h2 id="auto-39">Appendix B.<span style="margin-left: 1em"></span>Fortran best practice</h2>
      <p>
        It is a good practice to place procedures in modules (instead of
        internal procedures or external procedures) as it helps the compiler
        to detect programming errors and to optimize the code.
      </p>
      <p>
        Subroutines should be kept reasonably short (e.g. about 50 lines
        (usually difficult) so that they can fill in one screen and thus are
        easy to read).
      </p>
      <p>
        We now usually do not need to worry about the start up overheads
        involved in calling a subroutine, because some short subroutines can
        be &ldquo;inlined&rdquo; by compilers so that the inefficiency is
        generally not a problem.
      </p>
      <p>
        Each <code>module</code> should be in a separate file.
      </p>
      <p>
        Any code that introduces new physics to a code should have a switch to
        enable it to be turned off. This makes it possible to run the model in
        a configuration that is identical to the model before the new physics
        went in, in order to check that nothing unexpected has been broken.
      </p>
      <p>
        Code should be accompanied by technical documentation describing the
        physical processes that the additional code is intended to model and
        how this is achieved. Any equations used should be documented (in
        their continuous form where appropriate) along with the methods used
        to discretise these equations.
      </p>
      <p>
        Always bear in mind that somebody will have to maintain your code in
        the future. That person could be you several years later. Commenting
        the source lines that are not obvious from common senses. But do not
        make too extensive/detailed/specific comments because the details have
        good chance to become out-dated when codes are updated, which will
        make the comments inconsistent with the codes, causing confusion
        rather than clarification to code maintainers. Also, note that it is
        the code itself rather than the comment that is the final and absolute
        definition of what is exactly done in the code (i.e., every source
        code is self-documenting if you understand it). Therefore rather than
        investing much time in writing comments, we should spend more time in
        making the algorithm and code easy to understand even if there is no
        comment. Comments should be used to state the <strong>reason</strong>
        for doing something, instead of repeating the Fortran logic in words.
      </p>
      <p>
        The goal of all these practice is to reduce the chance of introducing
        bugs.
      </p>
      <p>
        
      </p>
      <p>
        All routines and documentation must be written using SI units.
        Standard SI prefixes may be used. Where relevant, the units used must
        be clearly stated in both code and documentation.
      </p>
      <p>
        Try to find some ways to test your code. Do not ignore compiler
        warnings, as they may point you to potential problems.
      </p>
      <p>
        http://jules-lsm.github.io/coding_standards/guidelines/best_practices.html
      </p>
      <p>
        
      </p>
      <p>
        We tend to criticize other's coding style when we see a messy code.
        But think twice before criticizing.
      </p>
      <p>
        At first glance of a code, your judgment of its readability is often
        false because it is based on the simple appearance of the code, i.e.,
        whether the code is neat enough rather than whether its logical is
        clear/straightforward or not, ==&gt;psychological reasons.
      </p>
      <p>
        But we should realize that work and life seem to be always in a hurry.
      </p>
      <p>
        
      </p>
      <p>
        http://annefou.github.io/Fortran/modules/modules.html
      </p>
      <p>
        
      </p>
      <p>
        Ref: 
      </p>
      <p>
        https://www.phy.ornl.gov/csep/pl/node1.html<span style="margin-left: 1em"></span>(this
        is very good)
      </p>
      <p>
        
      </p>
      <h2 id="auto-40">Appendix C.<span style="margin-left: 1em"></span>Stack vs Heap Memory
      allocation</h2>
      <p>
        Where are the stack and heap stored? They are both stored in the
        computer's RAM (Random Access Memory). Using RAM is faster than using
        virtual memory (paging file/swap file).
      </p>
      <p>
        Stack frame access is easier than the heap frame as the stack
        allocation happens on contiguous blocks of memory and hence is cache
        friendly, but in case of heap frames which are dispersed throughout
        the memory so it cause more cache misses. Note that the above being
        continugous or dispersed in memory refers to the storage of different
        variables, For a single array, all the data element are gauranteed to
        be continous in memory regardless they are on stack or heap.
      </p>
      <p>
        In a stack, the allocation and deallocation is automatically done,
        whereas, in heap, it needs to be done by the programmer manually.
      </p>
      <p>
        
      </p>
      <p>
        However, it is generally better to consider
        &ldquo;<strong>scope</strong>&rdquo; and
        &ldquo;<strong>lifetime</strong>&rdquo; rather than
        &ldquo;stack&rdquo; and &ldquo;heap&rdquo;.
      </p>
      <p>
        Scope refers to what parts of the code can access a variable.
        Generally we think of <strong>local scope</strong> (can only be
        accessed by the current function) versus <strong>global scope</strong>
        (can be accessed anywhere).
      </p>
      <p>
        Lifetime refers to when a variable is allocated and deallocated during
        program execution. Usually we think of <strong>static
        allocation</strong> (variable will persist through the entire duration
        of the program, making it useful for storing the same information
        across several function calls) versus <strong>automatic
        allocation</strong> (variable only persists during a single call to a
        function, making it useful for storing information that is only used
        during your function and can be discarded once you are done) versus
        <strong>dynamic allocation</strong> (variables whose duration is
        defined at runtime, instead of compile time like static or automatic).
      </p>
      <p>
        Although most compilers and interpreters implement this behavior
        similarly in terms of using stacks, heaps, etc, a compiler may
        sometimes break these conventions if it wants as long as behavior is
        correct. For instance, due to optimization a local variable may only
        exist in a register or be removed entirely, even though most local
        variables exist in the stack. You are free to implement a compiler
        that doesn't even use a stack or a heap, but instead some other
        storage mechanisms (rarely done, since stacks and heaps are great for
        this).
      </p>
      <p>
        A particularly poignant example of why it's important to distinguish
        between lifetime and scope is that a variable can have local scope but
        static lifetime. In the context of lifetime, &ldquo;static&rdquo;
        <em>always</em> means the variable is allocated at program start and
        deallocated when program exits.
      </p>
      <p>
        
      </p>
      <p>
        The value of a local scalar can be retained between different calls to
        the <code>subroutine/function</code> (by using <code>save</code>
        keyword or compiler option to save all local variables) but automatic
        arrays can not have the <code>save</code> attribute.
      </p>
    </div>
  </body>
</html>