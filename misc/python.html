<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Programming in Python</title>
    <meta charset="utf-8" content="TeXmacs 2.1.4" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } .underline { text-decoration: underline; }
      .overline { text-decoration: overline; } .strike-through {
      text-decoration: line-through; } del { text-decoration: line-through
      wavy red; } .fill-out { text-decoration: underline dotted; } 
    </style>
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong>Programming in
            Python</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">Youjun Hu</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        Institute of Plasma Physics, Chinese Academy of
                        Sciences
                      </p>
                      <p>
                        Email: yjhu@ipp.cas.cn
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <p>
      
    </p>
    <h2 id="auto-1">1.<span style="margin-left: 1em"></span>Introduction<span style="margin-left: 1em"></span></h2>
    <p>
      Python's emphasis on flexibility and readability, combined with
      high-level builtin data structures, dynamically typed variables, and
      verstile third-party libraries that are easily accessible, make it
      attractive for rapid prototyping, as well as for use as a scripting
      language to connect existing components together.
    </p>
    <p>
      Python is case sensitive. Python was designed for convenience and hence
      uses <strong>dynamically typed</strong> variables. Python is lexical
      scoped, which means the binding of a free variable inside a function can
      be infered from where the function is defined, without considering where
      the function is called (but the value of the free variable can depend on
      where the function is called because the value of the free variable can
      be modified somewhere).
    </p>
    <p>
      Python functions are first-class citizens, which means: they can be
      treated like any other variable, can be passed to a function, and can be
      returned from a function.
    </p>
    <p>
      Python's syntax emphasizes readability, similar to natural English
      (contrast to Perl). Python uses indentation for statement grouping.
      Whitespace (spaces and tabs) at the beginning of a logical line is used
      to compute the indentation level of the line, which is used to determine
      the grouping of statements (i.e. code blocks such as loops, branchings,
      function/class body). Indentation-based syntax is believed to enhances
      source code readability, considering the fact that visual layout is
      intuitively used by humans to perceive logical concepts.
    </p>
    <p>
      Other reasons why python is popular: All Python (intepretor) releases
      are open source. Python has an active community and lots of libraries
      and documentation. Python works on many platforms (e.g. Linux, Windows,
      Mac).
    </p>
    <p>
      Comments in python: (1) anything after a hash (<code>#</code>) is a
      comment. A comment signifies the end of the logical line unless the
      implicit line joining rules are invoked.  (2) triple quotes introduce
      string literals, which can have multiple-lines, and thus can serve as
      multiple-line comments.
    </p>
    <p>
      A python statement ends at a hash or at the end of a line (exception for
      open brackets, quotes, or parentheses). Semicolon can be used to put
      multiple statements in the same line. (This works only for some simples
      statements and does not work for compound statements due to the
      requirement of the layout syntax.) This syntax makes it legal to put a
      semicolon at the end of a single statement:
    </p>
    <pre class="verbatim" xml:space="preserve">
print(&quot;hello&quot;);</pre>
    <p>
      This statement means print(&ldquo;hello&rdquo;) and then do nothing. So,
      it's actually two statements where the second one is empty. This
      semantics is often used as a hint in iteractive environments for
      supressing output.
    </p>
    <h3 id="auto-2">1.1.<span style="margin-left: 1em"></span>Python reserved words<span style="margin-left: 1em"></span></h3>
    <p>
      The reserved words (keywords) in Python are as follows.
    </p>
    <p>
      Value: <code>True, False, None</code>
    </p>
    <p>
      Operator: <code>and, or, not, in, is</code>
    </p>
    <p>
      Control flow: <code>if, elif, else</code>, <code>for, while, break,
      continue, pass</code>, <code>return, yield</code>
    </p>
    <p>
      Structure definition: <code>def, class, lambda, with, as</code>
    </p>
    <p>
      Variable handling: <code>del, global, nonlocal</code>
    </p>
    <p>
      Import module: <code>import, from, as</code>
    </p>
    <p>
      Exception-handling: <code>try, except, raise, finally, else, with,
      assert</code>
    </p>
    <p>
      Asynchronous programming: <code>async, await</code>
    </p>
    <p>
      The keywords <code>else</code> and <code>as</code> have additional uses
      beyond their initial use cases. The <code>else</code> keyword is used
      with conditionals and loops, as well as with <code>try</code> and
      <code>except</code>. The <code>as</code> keyword is used in
      <code>import</code> as well as in the <code>with</code> keyword.
    </p>
    <p>
      Some identifiers are only reserved under specific contexts. These are
      known as soft keywords. The identifiers <code>match</code>,
      <code>case</code> and <code>_</code> can syntactically act as keywords
      in contexts related to the pattern matching statement, but this
      distinction is done at the parser level, not when tokenizing.
    </p>
    <h2 id="auto-3">2.<span style="margin-left: 1em"></span>Run Python code<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-4">2.1.<span style="margin-left: 1em"></span>Interactive mode<span style="margin-left: 1em"></span></h3>
    <ul>
      <li>
        <p>
          Using jupyter-notebook in a web-browser.
        </p>
      </li>
      <li>
        <p>
          In a Linux terminal, invoking <code>python</code> without any
          comand-line option will enter the interactive mode, where python
          source code can be typed in and run.
        </p>
      </li>
      <li>
        <p>
          Running short scripts directly from Shell. Use <code>python -c
          '&lt;script&gt;'</code>. For example:
        </p>
        <pre class="verbatim" xml:space="preserve">
python -c 'import math; t = math.pi; print(t)'</pre>
      </li>
    </ul>
    <h3 id="auto-5">2.2.<span style="margin-left: 1em"></span>Script file mode<span style="margin-left: 1em"></span></h3>
    <ul>
      <li>
        <p>
          Create a Python script file <code>a.py</code> (by using any text
          editor). Then run it in a Linux terminal by specifying the
          interpreter and the script file: <code>python a.py</code>.
        </p>
      </li>
      <li>
        <p>
          Another way (in Linux) is to specify the interpreter in the first
          line of a python script: <tt>#!/usr/bin/python3</tt>, and then give
          executable permission to this file: <code>chmod u+x a.py</code>. And
          run it in a Linux terminal: <code>./a.py</code>
        </p>
      </li>
      <li>
        <p>
          In emacs, I run a python code in a buffer by press F8, which runs a
          python interpreter on the file.
        </p>
      </li>
    </ul>
    <h2 id="auto-6">3.<span style="margin-left: 1em"></span>Python modules<span style="margin-left: 1em"></span></h2>
    <p>
      In Python, a plain text file containing Python code that is intended to
      be directly executed by the user is usually called script, which is an
      informal term that means top-level program file. On the other hand, a
      plain text file, which contains Python code that is intended to be
      imported and used from another Python file (or from the interactive
      mode), is called a module.
    </p>
    <h3 id="auto-7">3.1.<span style="margin-left: 1em"></span>Install a new module<span style="margin-left: 1em"></span></h3>
    <p>
      Command tool <tt class="verbatim"><code>python3-pip</code></tt> can be used to
      install a new package. For example, in a linux terminal,
    </p>
    <pre class="verbatim" xml:space="preserve">
pip3 install numpy</pre>
    <p>
      will install the <code>numpy</code> package.
    </p>
    <h3 id="auto-8">3.2.<span style="margin-left: 1em"></span>Use modules<span style="margin-left: 1em"></span></h3>
    <p>
      Use <code>import</code> to get access to python  modules. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
import foo</pre>
    <p>
      Then python will look for a file with name being <code>foo.py</code>
      first in the current directory and then in other directories assumed by
      python. If the file is found, it will be loaded. Here <code>foo</code>
      is called module name.
    </p>
    <p>
      It is customary to place all import statements at the beginning of a
      python file. More examples: 
    </p>
    <pre class="verbatim" xml:space="preserve">
import numpy as np
import matplotlib.pyplot as plt</pre>
    <p>
      Modules can import other modules. A module usually only contain function
      definitions. But a module can also contain executable statements. These
      statements are intended to initialize the module. They are executed only
      the first time the module name is encountered in an import statement.
    </p>
    <p>
      Each module has its own namespace, which is used as the global namespace
      by all functions defined in the module. Thus, the author of a module can
      use global variables in the module without worrying about accidental
      clashes with a user's global variables (this rule is just the lexical
      scoping). A user of a module can access global variables of a module by
      prefixing the variable with the namespace, i.e.,
      <code>modname.itemname</code>.
    </p>
    <p>
      We can also imports names from a module directly into the importing
      module's symbol table. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
from numpy import sin</pre>
    <p>
      which import a specific function to the current namespace. In this case,
      the namespace of numpy is not imported. Then <code>sin</code> can not be
      accessed by using <code>numpy.sin</code>.
    </p>
    <p>
      Another form of <code>import</code> is
    </p>
    <pre class="verbatim" xml:space="preserve">
from math import *</pre>
    <p>
      This imports all names (except those beginning with an underscore)
      defined in the <code>math</code> package directly in the calling
      module's namespace. In most cases Python programmers do not use this
      form since it introduces an unknown set of names into the namespace,
      shadowing some things you have already defined if there are name
      collisions.
    </p>
    <h2 id="auto-9">4.<span style="margin-left: 1em"></span>Objects, types, values, and name
    binding<span style="margin-left: 1em"></span></h2>
    <p>
      Objects are Python's abstraction for data. All data in a Python program
      is represented by objects. Every object has an identity, a type, and a
      value.
    </p>
    <p>
      An object's identity never changes once it has been created; you may
      think of it as the object's address in memory. The <code>id()</code>
      function returns an integer representing its identity. The
      &lsquo;<code>is</code>' operator compares the identity of two objects.
    </p>
    <p>
      An object's type determines the operations that the object supports and
      also defines the possible values for objects of that type. The
      <code>type()</code> function returns an object's type. Like its
      identity, an object's type is also unchangeable.
    </p>
    <p>
      Some objects contain other objects; these are called containers.
      Examples of containers are tuples, lists, sets, and dictionaries.
    </p>
    <p>
      Objects whose (first-level) elements are unchangeable once they are
      created are called immutable. An immutable object can contain an element
      that is a mutable object. When the elements of the contained mutable
      object are changed, the value of the imuutable object is changed.
      However the container is still considered immutable because the
      <code>id()</code> of its element are not changed. So, immutability is
      not the same as having an unchangeable value. 
    </p>
    <p>
      An object's mutability is determined by its type; for instance, numbers,
      strings and tuples are immutable, while dictionaries and lists are
      mutable.
    </p>
    <p>
      For immutable types, operations that compute new values may actually
      return a reference to any existing object with the same type and value,
      while for mutable objects this is not allowed. E.g., after <code>a = 1;
      b = 1</code>, <code>a</code> and <code>b</code> may or may not refer to
      the same object with the value one, depending on the implementation, but
      after <code>c = []; d = []</code>, <code>c</code> and <code>d</code> are
      guaranteed to refer to two different, unique, newly created empty lists.
    </p>
    <p>
      All python's objects were based on the C data structure no matter the
      object is a simple object such as an integer, i.e., primitive, or
      something more complicated such as a class.
    </p>
    <p>
      On high level of abstraction, concepts in python can be categorized into
      two concepts: names and objects. Names refer to objects. Names are
      usually called variables. A name is introduced by name binding
      operation, which binds the name to an object, i.e, naming the object.
      The following constructs bind names: assignments, class definitions,
      function definitions, formal parameters to functions, import statements,
      for loop header, a capture pattern in structural pattern matching.
    </p>
    <p>
      (The physical representation of a name is most likely a pointer, but
      that's simply an implementation detail. Name is actually an abstract
      notion at heart.)
    </p>
    <p>
      Objects have individuality, and multiple names can be bound to the same
      object. This is known as aliasing. 
    </p>
    <p>
      Let us first discuss the most basic name binding
      operation&mdash;assignements:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = 1
b = 1</pre>
    <p>
      Then <code>a</code> and <code>b</code> may or may not refer to the same
      object (this can be checked with the build-in function <code>id()</code>
      or using <code>a is b</code>, which, in my case, returns
      <code>True</code>)
    </p>
    <pre class="verbatim" xml:space="preserve">
a = []
b = []</pre>
    <p>
      Here two objects (empty lists) are created in memory, and are named as
      <code>a</code> and <code>b</code>, respectively. Therefore
      <code>a</code> and <code>b</code> are guaranteed to refer to two
      different objects. Consider another example:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = []
b = a</pre>
    <p>
      Here the second line give an alias to the object named <code>a</code>,
      rather than copying the objects. Therefore <code>a</code> and
      <code>b</code> refer to the same object.
    </p>
    <p>
      Objects are never explicitly destroyed; the may be implicitly destoyed:
      when they become unreachable they may be garbage-collected. An
      implementation is allowed to postpone garbage collection or omit it
      altogether &mdash; it is a matter of implementation quality how garbage
      collection is implemented, as long as no objects are collected that are
      still reachable.
    </p>
    <p>
      Python assignment statements do not return values.
    </p>
    <p>
      Python adopts dynamical typing, which means type checking happens at run
      time. In dynamically typed languages, typing is associated with the
      object that a variable refers to rather than the variable itself.
      Therefor there is no type declaration for variables. And a variable
      pointing to an object of a type can be later used to point to an object
      of another type.
    </p>
    <p>
      Here is the type h<strong></strong>ierarchy of Python:
    </p>
    <p>
      <span style="margin-left: 2em"></span>* Numbers:
    </p>
    <p>
      <span style="margin-left: 4em"></span>* Integral: Plain Integers, Long Integers, Booleans.
    </p>
    <p>
      <span style="margin-left: 4em"></span>* Non-Integral: Floating point numbers, Decimals
      &amp; Fractions,
    </p>
    <p>
      <span style="margin-left: 11em"></span>Complex numbers.
    </p>
    <p>
      <span style="margin-left: 2em"></span>* Collections:
    </p>
    <p>
      <span style="margin-left: 5em"></span>* Sequences: string, tuple, list, byte.
    </p>
    <p>
      <span style="margin-left: 5em"></span>* Sets: set.
    </p>
    <p>
      <span style="margin-left: 5em"></span>* Maps: Dictionary.
    </p>
    <p>
      <span style="margin-left: 2em"></span>* Callables: functions, generators, classes,
      methods.
    </p>
    <p>
      <span style="margin-left: 2em"></span>* Singleton:  None, NotImplemented, Ellipsis
      (&hellip;), exceptions.
    </p>
    <h3 id="auto-10">4.1.<span style="margin-left: 1em"></span>Parallel assignments, comma operator,
    unpacking<span style="margin-left: 1em"></span></h3>
    <pre class="verbatim" xml:space="preserve">
a, b = 0, 1</pre>
    <p>
      This is known as parallel assignment. If the right-hand side of the
      assignment is a single variable (e.g. a list or tuple), the feature is
      called unpacking or destructuring assignment:
    </p>
    <pre class="verbatim" xml:space="preserve">
a, b = (2, 3)</pre>
    <p>
      This unpacks a tuple of two elements into two variables.
    </p>
    <p>
      
    </p>
    <p>
      In a for loop, argument unpacking can be used along the built-in
      <code>zip()</code>, which allows you to iterate through two or more
      sequences at the same time. On each iteration,  <code>zip()</code>
      returns a tuple that collects one element from each of the sequences:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; first = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&gt;&gt;&gt; second = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
&gt;&gt;&gt; third = [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;]
&gt;&gt;&gt; for one, two, three in zip(first, second, third):
&hellip;     print(one, two, three)
&hellip;
a d g
b e h
c f i</pre>
    <p>
      More examples of unpacking:
    </p>
    <p>
      <code><p>
        (a, b) = (10, (20,30))
      </p><p>
        a, b<span style="margin-left: 1em"></span>= (10, (20,30))
      </p><p>
        [x,y] = [2,3]
      </p><p>
        x,y<span style="margin-left: 1em"></span>= [2,3]
      </p><p>
        a,b,c = 'Hey'
      </p><p>
        p, *q = &ldquo;Hello&rdquo; # p will be &ldquo;H&rdquo; and q will be
        the rest
      </p><p>
        p, *q, j = [1,2,3,4,5]
      </p></code>
    </p>
    <p>
      This kind of unpacking appear often in everyday coding, in a disguised
      way when  several variables are bound to the return value of a function
      which returns multiply items. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)
fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(nrows=2, ncols=2)</pre>
    <h2 id="auto-11">5.<span style="margin-left: 1em"></span>Flow control<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-12">5.1.<span style="margin-left: 1em"></span>Logical expressions<span style="margin-left: 1em"></span></h3>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">Equals</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid"><code>==</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Not Equals</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>!=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&lt;</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than or equal to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&lt;=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"> <code>&gt;</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than or equal to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&gt;=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Belongs to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>in</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">object identity</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>is</code></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><div class="caption">
          <font style="font-size: 84.1%"><p>
            <b>Table 1. </b><a id="auto-13"></a>Relation operators
          </p></font>
        </div></td>
      </tr></tbody>
    </table>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">logical and</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid"><code>and</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">logical or</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>or</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">logicl not</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>not</code></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><div class="caption">
          <font style="font-size: 84.1%"><p>
            <b>Table 2. </b><a id="auto-14"></a>Logical operators
          </p></font>
        </div></td>
      </tr></tbody>
    </table>
    <p>
      The returned values by the above operators are of logical type (also
      called bool). (Logical type is a subclass of integral numbers.) Logical
      expressions can be used in several ways, most commonly in conditionals
      and loops.
    </p>
    <h3 id="auto-15">5.2.<span style="margin-left: 1em"></span>Conditionals<span style="margin-left: 1em"></span></h3>
    <p>
      Python <code>if</code> structure takes the following form:
    </p>
    <pre class="verbatim" xml:space="preserve">
if a==0:
    print(&quot;a is zero&quot;)
elif a&lt;0:
    print(&quot;a is negative&quot;)
else:
    print(&quot;a is positive&quot;)</pre>
    <p>
      The blocks in a <code>if</code> structure does not introduce a new
      scope. Therefore, if new variables are defined in the blocks, they are
      defined in the global namespace and thus will be still visible outside
      the <code>if</code> structure. The same applies to the loop structure.
      (This is different from C)
    </p>
    <p>
      One-line <code>if</code> structure:
    </p>
    <pre class="verbatim" xml:space="preserve">
if a &gt; b: print(&quot;a is greater than b&quot;)</pre>
    <p>
      If you have only one statement to execute, one for if, and one for else,
      you can put it all on the same line:
    </p>
    <pre class="verbatim" xml:space="preserve">
print(&quot;A&quot;) if a &gt; b else print(&quot;B&quot;)</pre>
    <p>
      The advantage of one-line <code>if</code> structure is that we can pass
      the return value seamlessly to other operation (functional style). For
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
abs_a = (a if a&gt;=0 else -a)</pre>
    <p>
      Another usage of the one-line <code>if</code> structure is in the list
      comprehension (although not very readable):
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
&gt;&gt;&gt; prices = [i if i &gt; 0 else 0 for i in original_prices]
&gt;&gt;&gt; prices
[1.25, 0, 10.22, 3.78, 0, 1.16]</pre>
    <p>
      A more readable way would be defining a function and using that function
      in the comprehension:
    </p>
    <pre class="verbatim" xml:space="preserve">
def f(i):
    return i if i&gt;0 else 0
prices = [f(i) for i in original_prices]</pre>
    <h3 id="auto-16">5.3.<span style="margin-left: 1em"></span>Loop structure<span style="margin-left: 1em"></span></h3>
    <p>
      Python has two primitive loops: <code>while</code> loop and
      <code>for</code> loop.
    </p>
    <h4 id="auto-17">5.3.1.<span style="margin-left: 1em"></span>While-loop<span style="margin-left: 1em"></span></h4>
    <p>
      
    </p>
    <pre class="verbatim" xml:space="preserve">
i = 1 # while-loop requires relevant variables to be ready
while i &lt; 6:
     print(i)
     i = i + 1</pre>
    <p>
      The above <code>while</code> loop is similar to those in Fortran and C.
    </p>
    <h4 id="auto-18">5.3.2.<span style="margin-left: 1em"></span>Collection-based loop: For-loop<span
    style="margin-left: 1em"></span></h4>
    <p>
      Another python loop structure is the <code>for</code> loop, which
      iterates over an iterable object, capturing each element to a local
      variable for use by the attached block. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
for x in fruits:
    print(x)</pre>
    <p>
      In the above, <code>x</code> acts as a dummy variable, which does not
      need to be defined before the loop. The <code>for</code> loop does not
      form a new scope. This means that the variable <code>x</code> is
      acessible outside the loop. On exist from the <code>for</code> loop, the
      value of <code>x</code> is equal to the value got from the last
      iteration. If <code>x</code> is defined before the <code>for</code>
      loop, its value will be modified by the <code>for</code> loop.
    </p>
    <p>
      Note that the keyword <code>in</code> is used in Python for two
      different (but related) purposes: (1) The <code>in</code> keyword is
      used to check if a value is present in a sequence (list, range, string
      etc.). (2) Combined with <code>for</code>, it is used to iterate through
      a sequence.
    </p>
    <p>
      The <code>continue</code> statement skips the remainder of the current
      iteration and continues with the next. The <code>break</code> satement
      exits a loop.
    </p>
    <p>
      The advantage of collection-based iteration is that it helps avoid the
      off-by-one bug (considered as the No. 1 bug by programmers) that is
      common in other programming languages. The collection-based iteration is
      borrowed from bash?
    </p>
    <p>
      Collection-based loop can also be nested. For example
    </p>
    <pre class="verbatim" xml:space="preserve">
list_of_lists = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]
for list in list_of_lists:
    for x in list:
        print(x)</pre>
    <p>
      
    </p>
    <font color="blue"><p>
      The collection-based <tt>for</tt> loop is less like the <code>for</code>
      loop in C, which looks like the following:
    </p><pre class="verbatim" xml:space="preserve">
for(i=start; i&lt;some_threthod; some_operation_modifying_i) {loop_body}</pre><p>
      which is essentially a <code>while</code> loop discussed above.
    </p></font>
    <h2 id="auto-19">6.<span style="margin-left: 1em"></span>Functions<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-20">6.1.<span style="margin-left: 1em"></span>Define and call a function<span style="margin-left: 1em"></span></h3>
    <p>
      Use keyword <code>def</code> to define a function:
    </p>
    <pre class="verbatim" xml:space="preserve">
def func_name ( arg1, arg2, argN ):
    some_codes
    return something</pre>
    <p>
      Call a function:
    </p>
    <pre class="verbatim" xml:space="preserve">
func_name(arg1, arg2, argN) #the returned value is not captured
a = func_name(arg1, arg2, argN)</pre>
    <p>
      Note that a bare function name without a parameter tuple refers to a
      function object rather than calling a function.
    </p>
    <p>
      Functions can return multiple items:
    </p>
    <pre class="verbatim" xml:space="preserve">
def func():
    return 'a', 3, (1,2,3)  # returns a tuple of 3 elements
x1, x2, x3 = func()  # unpacks the tuple of 3 elements into 3 vars
# x1: 'a'
# x2: 3
# x3: (1,2,3)</pre>
    <h3 id="auto-21">6.2.<span style="margin-left: 1em"></span>Arguments are passed by assignment<span
    style="margin-left: 1em"></span></h3>
    <p>
      Some languages (e.g. Fortran) handle function arguments as references to
      existing variables, which is known as pass by reference. Other languages
      (e.g. C) handle them as independent values, an approach known as pass by
      value.
    </p>
    <p>
      Python assigns a unique identifier to each object and this identifier
      can be found by using Python's built-in <code>id()</code> function. It
      is ready to verify that actual and formal arguments in a function call
      have the same id value, which indicates that the dummy argument and
      actual argument refer to the same object.
    </p>
    <p>
      Note that the actual argument and the corresponding dummy argument are
      two names referring to the same object. If you re-bind a dummy argument
      to a new value/object in the function scope, this does not effect the
      fact that the actual argument still points to the original object
      because actual argument and dummy argument are two names.
    </p>
    <p>
      Using the semantics of the assigenment in Python, the above facts can be
      summarized as &ldquo;arguments are passed by assignment&rdquo;, i.e., 
    </p>
    <pre class="verbatim" xml:space="preserve">
dummy_argument = actual_argument</pre>
    <p>
      If you re-bind dummy_argument to a new object in the function body, the
      <code>actual_argument</code> still refers to the original object. If you
      use <code>dummy_argument[0] = some_thing</code>, then this will also
      modify <code>actual_argument[0]</code>. Therefore the effect of
      &ldquo;pass by reference&rdquo; can be achieved by modifying the
      components/attributes of the object reference passed in. (In practice,
      returning multiple values from functions is usually better than
      employing the effect of passing by reference.)
    </p>
    <p>
      To make comparison with other languages, you can say Python passes
      arguments by value in the same way as C does, where when you pass
      &quot;by reference&quot; you are actually passing by value the reference
      (i.e., the pointer)
    </p>
    <h3 id="auto-22">6.3.<span style="margin-left: 1em"></span>Parameter list<span style="margin-left: 1em"></span></h3>
    <p>
      The format of parameter list of a function defintion determines the
      possible ways in which the user provides actual arguments. The following
      are typical parameter lists:
    </p>
    <pre class="verbatim" xml:space="preserve">
def f(x, y):  #case1
def f(x, y=0): #case2: optional parameters with default values
def f(x, y, *, z): #case3
def f(x, y, /, w, q, *, z): #case4
def f(x, y, *arg, **kwarg): #case5
def f(x, y=0, *arg, **kwarg): #case6</pre>
    <p>
      For case1,  <code>f</code> can be called with positional arguments (e.g.
      f(2,3)), keywords arguments (e.g., f(x=2, y=3)), or the mixed way
      (e.,g., f(x, y=3)). For the mixed way, positional arguments must go
      first and then keyword arguments. The advantage of keyword arguments is
      that they may be specified in arbitrary order.
    </p>
    <p>
      In case2,  we use <code>par = value</code> to define a parameter with a
      default value. Default parameters are introduced to allow some arguments
      to be omitted when the function is called (i.e., they are optional).
      Non-defualt parameters are not allowed after a default parameter. For
      example, <code>def f(x, y=0, z):</code> will generate SyntaxError.
    </p>
    <p>
      Default parameter values are defined only once when the function is
      defined (that is, when the <code>def</code> statement is executed). If
      you specify a mutable object as the default value for a parameter and
      the function is called mutiple times with the default parameter omitted,
      then the operation on the object will be accumated (e.g., appending to a
      list).
    </p>
    <p>
      Note that <strong>optional/default</strong> parameters and keyword
      arguments take similar froms. The difference is that optional/default
      parameters are for function defintion while keywords arguments are for
      function invokation.
    </p>
    <p>
      Cases 3 and 4: A bare star &ldquo;<code>*</code>&rdquo; indicates all
      the following parameters are keyword-only parameters. A
      &ldquo;<code>/</code>&rdquo; indicates all parameter before it are
      position-only parameters.
    </p>
    <p>
      Case 5 and case 6 are explained in the following section.
    </p>
    <h4 id="auto-23">6.3.1.<span style="margin-left: 1em"></span>Arguments packing<span style="margin-left: 1em"></span></h4>
    <p>
      A dummy argument, which appear in a function defintion, is often
      referred to as &ldquo;parameter&rdquo;. An actual argument, which
      appears in a function call, is often referred to as
      &ldquo;argument&rdquo;. But most people do not stick to this rule and
      use &ldquo;argument&rdquo;/&ldquo;parameter&rdquo; without specifying
      whether it is a dummy or actual argument. Therefore, when seeing the
      word &ldquo;argument&rdquo;, we need to judge from the contex whether it
      refers to a dummy argument or actual argument. I will use
      &ldquo;formal&rdquo;/&ldquo;actual&rdquo; to distinguish between them.
    </p>
    <p>
      Besides standard positional arguments, there is a special formal
      argument that can accept a group of positional arguments (not keyword
      arguments) and pack them into a single iterable object:
    </p>
    <pre class="verbatim" xml:space="preserve">
def my_sum(*args):
    result = 0
    for x in args:
        result += x
    return result
&gt;&gt;&gt; my_sum(1, 2, 3)
6</pre>
    <p>
      Here <code>my_sum()</code> takes all the actual arguments and packs them
      into a single iterable object (named <code>args</code> in this case).
      The name <code>args</code> does not matter. All that matters here is
      that you use the unpacking operator (*) before <code>args</code>.
    </p>
    <p>
      **kwargs works just like *args, but instead of accepting positional
      arguments it accepts keyword (or named) arguments. Take the following
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
def concatenate(**kwargs):
    result = &quot;&quot;
    for arg in kwargs.values():
        result += arg
    return result
print(concatenate(a=&quot;Hello&quot;, b=&quot;World&quot;, c=&quot;!&quot;))</pre>
    <p>
      Note that the keyword arguments are packed into a standard dict. If you
      iterate over the dictionary and want to return its values, like in the
      example shown, then you must use <code>kwargs.values()</code>.
    </p>
    <p>
      To recap, in a function defintion, use <tt>*args</tt> and
      <tt>**kwargs</tt> to accept a changeable number of positional arguments
      and keyword argument, respectively.
    </p>
    <p>
      
    </p>
    <p>
      When defining a function, the correct order for parameters is:
    </p>
    <ol>
      <li>
        <p>
          non-default parameters
        </p>
      </li>
      <li>
        <p>
          default parameters
        </p>
      </li>
      <li>
        <p>
          *args arguments
        </p>
      </li>
      <li>
        <p>
          **kwargs arguments
        </p>
      </li>
    </ol>
    <p>
      When calling a function, the correst order for argument is:
    </p>
    <ol>
      <li>
        <p>
          positional arguments
        </p>
      </li>
      <li>
        <p>
          keyword arguments
        </p>
      </li>
    </ol>
    <h4 id="auto-24">6.3.2.<span style="margin-left: 1em"></span>Arguments unpacking<span style="margin-left: 1em"></span></h4>
    <p>
      In the above, we see that, when a parameter name in a Python function
      definition is preceded by an asterisk (*), it indicates that any
      corresponding arguments in the function call are packed into a tuple
      that the function can refer to by the given parameter name. An analogous
      operation is available when calling a function. When an argument in a
      function call is preceded by an asterisk (*), it indicates that the
      argument is a tuple that should be unpacked and passed to the function
      as separate values. The asterisk (*) operator can be applied to any
      iterable in a Python function call.
    </p>
    <p>
      Preceding a parameter in a Python function definition by a double
      asterisk (**) indicates that the corresponding keyward arguments should
      be packed into a dictionary. An analogous operation is available when
      calling a function. When the double asterisk (**) precedes an argument
      in a Python function call, it specifies that the argument is a
      dictionary that should be unpacked, with the resulting items passed to
      the function as keyword arguments.
    </p>
    <h3 id="auto-25">6.4.<span style="margin-left: 1em"></span>Generator Function using yied<span style="margin-left: 1em"></span></h3>
    <p>
      Generators, in essence, are a special kind of iterators that are
      evaluated lazily by rendering elements one by one without the need for
      loading all elements in the memory.
    </p>
    <p>
      The regular definition of generators involves the use of the
      <code>yield</code> keyword, which means sending values back to the
      caller. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
# a generator yields items instead of returning a list
def firstn(n):
    num = 0
    while num &lt; n:
        yield num
        num += 1
sum_of_first_n = sum(firstn(1000000))</pre>
    <p>
      When you call a function that contains a yield statement anywhere, you
      get a generator object, but no code runs. Then each time you extract an
      object from the generator, Python executes code in the function until it
      comes to a yield statement, then pauses and delivers the object. When
      you extract another object, Python resumes just after the yield and
      continues until it reaches another yield (often the same one, but one
      iteration later). This continues until the function runs off the end, at
      which point the generator is deemed exhausted.
    </p>
    <p>
      Generator expressions provide a shortcut to build generators out of
      expressions.
    </p>
    <pre class="verbatim" xml:space="preserve">
doubles = list(2*n for n in range(50))</pre>
    <p>
      By allowing generator expressions, we don't have to write a generator
      function.
    </p>
    <p>
      List comprehensions are closer to syntactic sugar for a generator
      expression inside a list().
    </p>
    <h3 id="auto-26">6.5.<span style="margin-left: 1em"></span>Nested function, return function as value,
    closure<span style="margin-left: 1em"></span></h3>
    <p>
      In Python, we can define a function inside the body of a function
      (nested function). The inner functions have access to all outer
      variables in the enclosing functions. The inner functions can be called
      in the body of the enclosing function body. This feature is commonplace
      and can be found in most languages. What is interesting is that the
      inner function can also be returned as the return value of the enclosing
      function. This feature is only available in languages that treat
      function as a first citizen. For example
    </p>
    <pre class="verbatim" xml:space="preserve">
def power_factory(exp):
    def power(base):
        return base**exp
    return power

square = power_factory(2)
square(10)  #give 100
cube = power_factory(3)
cube(10) #give 1000</pre>
    <p>
      Variables like <code>exp</code> in the inner fucntion are called free
      variables. They are variables that are used in a code block but not
      defined there. When you return the inner function as the return value of
      the enclosing function, python needs to remember the values of these
      free variables (otherwise the returned function is meaningless). In
      other words, when you handle a nested function as value, the inner
      function are packaged together with the environment in which they
      execute. The resulting object is known as a closure. In other words, a
      closure is an inner function that carries information about its
      enclosing scope, even though its ecnclosing scope has completed its
      execution.
    </p>
    <p>
      Another famous example of making use of closure is to generate the
      derivative function of a given function:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; def derivative(f, dx):
        def prime(x):
            return (f(x+dx)-f(x))/dx
        return prime
&gt;&gt;&gt; dx = 0.01
&gt;&gt;&gt; mycos = derivative(math.sin, dx)
&gt;&gt;&gt; mycos(2.0)</pre>
    <p>
      A more interesting example is an accumulator generator making use of
      <tt>nonlocal</tt> keyword:
    </p>
    <pre class="verbatim" xml:space="preserve">
def foo(n):
    def inc(x):
        nonlocal n
        n += x
        return n
    return inc

acc = foo(10)
print(acc(1)) # Output: 11
print(acc(2)) # Output: 13 </pre>
    <h3 id="auto-27">6.6.<span style="margin-left: 1em"></span>Function decorators<span style="margin-left: 1em"></span></h3>
    <p>
      A decorator wrap a function, modifying its behavior. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
def my_decorator(say_hi):
    def wrapper(name):
        print('before')
        say_hi(name)
        print('after')
    return wrapper</pre>
    <p>
      The above function accepts a function and returns a function very
      similar to the orginal one. Next, define a function and pass it to the
      above function and capture the result with the same function name:
    </p>
    <pre class="verbatim" xml:space="preserve">
def say_hi(name):
    print(f&quot;hi!, {name}&quot;)
say_hi = my_decorator(say_hi)</pre>
    <p>
      Python introduces the function decorator syntax to achive the same
      effect:
    </p>
    <pre class="verbatim" xml:space="preserve">
@my_decorator
def say_hi(name):
    print(f&quot;hi!, {name}&quot;)</pre>
    <p>
      To recap, preceding a function defintion with <code>@dec</code> is
      equivalent to defining that function first and then passing the function
      name to the <code>dec</code> function, and capture the returned function
      with the orginal function name.
    </p>
    <h3 id="auto-28">6.7.<span style="margin-left: 1em"></span>Function call vs keyword structure<span
    style="margin-left: 1em"></span></h3>
    <p>
      Arguments in a function call are enclosed in round-brackets whereas
      arguments to a keyword statement are usually provided without
      round-brackets. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
del x</pre>
    <p>
      where <code>del</code> is a keyword statement and thus its argument
      <code>x</code> is not enclosed by round-brackets. In Python3,
      <code>print</code> becomes a function (in python2, it is a keyword
      statement). Therefore, arguments to python3 print must be enclosed by
      round-brackets: <code>print(&ldquo;hello&rdquo;)</code>.
    </p>
    <h3 id="auto-29">6.8.<span style="margin-left: 1em"></span>Built-in functions<span style="margin-left: 1em"></span></h3>
    <p>
      Complete list of python built-in functions can be found at <a href="https://docs.python.org/3/library/functions.html">https://docs.python.org/3/library/functions.html</a>.
      As an example of useful built-in functions, <code>dir()</code>, without
      arguments, return the list of names in the current local scope. With an
      argument, <code>dir</code> attempt to return a list of attributes and
      methods for that object. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
dir(__builtins__)</pre>
    <p>
      returns all names defined in <code>__builtins__</code>.
    </p>
    <h2 id="auto-30">7.<span style="margin-left: 1em"></span>Namespace and Scoping rule<span style="margin-left: 1em"></span></h2>
    <p>
      A variable defined inside a function's body is known as a local
      variable. Formal arguments identifiers also behave as local variables. A
      variable created outside of functions is known as a global variable,
      which can be called a free variable from the perspective of a function.
    </p>
    <p>
      Python adopts the lexical scope, which means the binding of a free
      variable inside a function can be infered without considering where the
      function is called (but the value of the free variable can depend on
      where the function is called because the value of the free variable can
      be modified somewhere).
    </p>
    <p>
      If a variable is <strong>assigned</strong> a value anywhere within the
      function's body, it's assumed to be a <strong>local</strong> unless
      explicitly declared as <code>global</code> or <code>nonlocal</code>. The
      locality of the variable will apply before the assignment creating the
      local variable, and thus if we use it before the assignment, we will get
      the UnboundLocalError: local variable 'x&rdquo; referenced before
      assignment. I.e., you can not use a name as a global variable first and
      then use it as a local variable.
    </p>
    <p>
      A global statement indicates the corresponding name live in the global
      scope. It does not require that the name is pre-bound.
    </p>
    <p>
      In a nested scope, we can use keyword <code>nonlocal</code> to declare
      that a variable is from enclosing scopes (scopes enclosing the present
      scope) but not a global. In other words, <code>nonlocal</code> means
      &ldquo;not a global or a local variable&rdquo;. The nonlocal statement
      causes corresponding names to refer to previously bound variables in the
      nearest enclosing function scope. SyntaxError is raised at compile time
      if the given name does not exist in any enclosing function scope.
    </p>
    <p>
      A namespace is a mapping from names to objects. Most namespaces are
      currently implemented as Python dictionaries, i.e., a namespace is a
      dictionary mapping names (as strings) to values. If you have access to a
      namespace, then you can access all the names in that namespace by using
      the dot notation, e.g., <code>numpy.sin</code>.
    </p>
    <p>
      A scope rule defines which namespaces will be looked in and in what
      order. When you make a reference, e.g., <code>print(foo)</code>, Python
      looks through a list of namespaces to try to find one with the name as a
      key. Note that we are not specifying which namespace <code>foo</code>
      belongs to (because we are not using the dot notation). Therefore Python
      will determine which namespace <code>foo</code> belongs to by searching
      a chain of namesapce. This is the scoping rule, i.e., the order in which
      a language looks up names. In python, the scoping rule is as follows. If
      you reference a name, then Python will look that name up sequentially in
      the Local, Enclosing, Global, and Built-in namespaces. If the name
      exists, then you'll get the first occurrence of it. Otherwise, you'll
      get an error. This rull is often called LEGB rule.
    </p>
    <p>
      When we say x is in a function's namespace, we mean it is defined there,
      locally within the function. When we say x is in the function's scope,
      we mean x is either in the function's namespace or in any of the outer
      namespaces that the function's namespace is nested inside.
    </p>
    <p>
      Whenever you define a function (using <code>def</code> or
      <code>lambda</code>), you create a new namespace and a new scope. The
      namespace is the new, local hash of names. The scope is the implied
      chain of LEGB.
    </p>
    <p>
      When we say that a variable in a namespace is in scope in a code block,
      we mean it is directly accessible for the block. &ldquo;Directly
      accessible&rdquo; here means that you do not need to qualified the name
      with namespace name being suffix.
    </p>
    <p>
      Classes defintion introduces a new namespace but does not introduce a
      new scope that functions defined in the class can see. Therefore, if a
      function defined in a class want to refer to a class attribute, the
      variable must be qualified with the class name using the dot notation.
    </p>
    <p>
      Create a namespace using a dictionary:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; from argparse import Namespace
&gt;&gt;&gt; x = {'a': 1, 'b': 2}
&gt;&gt;&gt; ns = Namespace(**x)
&gt;&gt;&gt; ns.a
1</pre>
    <p>
      
    </p>
    <p>
      Lexical scoping:
    </p>
    <pre class="verbatim" xml:space="preserve">
x = 1
def myfun():
    return x
x = 10
myfun()  # return 10 </pre>
    <p>
      Q: Is the above behavior consistent with lexical scoping?
    </p>
    <p>
      Q.Yes, it is. myfun is using the x variable from the environment where
      it was defined, but that x variable now holds a new value. Lexical
      scoping means functions resovle variables from the scope where they were
      defined, but it doesn't mean they have to take a snapshot of the values
      of those variables at the time of function definition. The code line
      <code>x = 1</code> can be dropped and the codes are still valid, i.e.,
      <code>x</code> can be un-bound when the function is defined.
    </p>
    <p>
      Lexical scoping means functions resolve free variables from the scope
      where they were defined, not from the scope where they are called.
    </p>
    <p>
      The local namespace for a function is created when the function is
      called, and deleted when the function returns or raises an exception
      that is not handled within the function. Recursive invocations each have
      their own local namespace.
    </p>
    <h2 id="auto-31">8.<span style="margin-left: 1em"></span>Class<span style="margin-left: 1em"></span></h2>
    <p>
      Class concept is a way of bundling data and functionality together, and
      supporting extention (i.e., inheritance).
    </p>
    <p>
      Define a new class define a new type, allowing new instances of that
      type to be created. The process of creating the object of that type is
      called instantiation. Class allows independent instances with different
      data (and the same functionality) to be created.
    </p>
    <p>
      Compared with C++, Python introduces class concepts with a minimum of
      new syntax and semantics. Class definition is syntactically similar to
      function definition. The <code>class</code> statement executes a block
      of code and attaches its local namespace to a class. The following is an
      example of defining a class:
    </p>
    <pre class="verbatim" xml:space="preserve">
class Vector:
    scale = 1
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    def show(self):
        print(f'{self.x}+{self.y}j')
        print(f'scale={self.scale}')</pre>
    <p>
      The above define a class named <code>Vector</code>, with two methods and
      three attributes named <code>scale</code>, <code>x</code>, and
      <code>y</code>.
    </p>
    <p>
      In practice, the statements inside a class definition will usually be
      function definitions. The function definitions inside a class must
      follow a peculiar form of argument list: The first dummy argument of a
      method is assumed by Python to be the object in question. The dummy
      object name is usually called <code>self</code>. This name is just a
      user convention: you can use an arbitry name here (i.e., what matters is
      its position in the argument list, not its name). When the method is
      called using the dot notation <code>object.method(args)</code>, users
      must omit the object name from the argument list, and the name is
      figured out and inserted to the argument list by python behind the
      scene.
    </p>
    <p>
      In a method, attributes of a class instance are created or referred to
      by using the dot notation: <code>self.attribute</code>. In the above,
      <code>self.x</code> and <code>self.y</code> are attributes of an
      instance, whereas <code>scale</code> is an attribute of the class. Note
      that, if the usual scoping rule applies (i.e., the class defintion forms
      a parent scope for its methods), the attribute <code>scale</code> should
      be assessible in the method by using the name <code>scale</code>. It
      turns out we can refer to <code>scale</code> but must use a different
      name: the attribute must be qualified with the class name, i.e.,
      <code>Vector.scale</code>. This indicates that the scope of names
      defined in a class block is limited to the class block, i.e they don't
      create an enclosing scope for methods. This is one of the new rules
      introduced to facilitate class defintion, i.e., class defintion body is
      not used as a parent scope for methods (Otherwise, it would make class
      inheritance confusing: e.g., a method inherited by a subclass would have
      access to the subclass scope.) Put it another way: Although classes
      define a class local scope or namespace, they don't create an enclosing
      scope for methods.
    </p>
    <p>
      
    </p>
    <p>
      Class Attribute vs. Instance Attribute
    </p>
    <ul>
      <li>
        <p>
          An instance attribute is a Python variable belonging to one, and
          only one, object. This variable is only accessible in the scope of
          this object and it is defined inside the methods (typically in
          <tt>__init__</tt>) of the class.
        </p>
      </li>
      <li>
        <p>
          A class attribute is a Python variable that belongs to a class
          rather than a particular object. It is shared between all the
          objects of this class and it is defined outside the methods of the
          class.
        </p>
      </li>
    </ul>
    <p>
      Python classes and objects have different namespaces. The name resolving
      rule is that the object namespace is before the class namespace: When
      you access an attribute of an object using the dot convention, it
      searches first in the namespace of that object for that attribute name.
      If it is found, it returns the value, otherwise, it searches in the
      namespace of the class. If nothing is found there as well, it raises an 
      AttributeError. When you access an attribute as a class property, it
      searches directly in the class namespace for the name of that attribute.
      If it is found, it returns the value, otherwise, it raises an
      AttributeError.
    </p>
    <p>
      
    </p>
    <p>
      Now we can use the class <code>Vector</code> defined above to create an
      object:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = Vector(2,3)</pre>
    <p>
      Class instantiation uses function notation with the class name serving
      as a function name. The returned value is a new instance of the class.
    </p>
    <p>
      Class functions that begin with double underscore __ are called special
      functions as they have special meaning. Of one particular interest is
      the <tt>__init__()</tt> function. This special function gets called
      whenever a new object of that class is instantiated. This type of
      function is also called constructors in other programming languages. We
      normally use it to initialize all the variables.
    </p>
    <p>
      Next, examine the instance we created above:
    </p>
    <pre class="verbatim" xml:space="preserve">
a.show() #a is implitcitly provided as the first argument
print(a.x)</pre>
    <p>
      In Python, attributes may be referenced/created by methods as well as by
      users of an object (i.e., attributes of an class/object can be created
      on the fly). There are no &ldquo;private&rdquo; instance variables
      (variables that can only be accessed within methods of an object). In
      other words, it is imposible to enforce data hiding in python &mdash; it
      is all based upon convention. The convention (followed by most Python
      code) is: a name prefixed with an underscore (e.g. _spam) should be
      treated as a non-public part of the API (whether it is a method or a
      data member).
    </p>
    <p>
      Note that clients may add data attributes of their own to an instance
      object. As long as name conflicts are avoided, adding new data
      abttributs does not affect the validity of the methods.
    </p>
    <p>
      The global scope associated with a method is the module containing its
      definition. (A class is never used as a global scope.) Typical global
      entites used in a methods are functions and modules imported in the
      global scope.
    </p>
    <p>
      instance method vs. class method vs static method
    </p>
    <p>
      Any method we create in a class will automatically be created as an
      instance method. We must explicitly tell Python that it is a class
      method or static method.
    </p>
    <p>
      Use the @classmethod decorator or the classmethod() function to define
      the class method.
    </p>
    <p>
      Use the @staticmethod decorator or the staticmethod() function to define
      a static method.
    </p>
    <p>
      we'll find some good reasons why a method would want to reference its
      own class.
    </p>
    <p>
      
    </p>
    <p>
      Finally, notice that the class .__dict__ and the instance .__dict__ are
      totally different and independent dictionaries. That's why class
      attributes are available immediately after you run or import the module
      in which the class was defined. In contrast, instance attributes come to
      life only after an object or instance is created.
    </p>
    <p>
      
    </p>
    <p>
      Classes themselves are objects, which means that a class name can be
      rebound to new names. This makes importing easy, where we can rename a
      class name to a new simple name.
    </p>
    <p>
      
    </p>
    <p>
      Most built-in operators with special syntax (arithmetic operators,
      subscripting etc.) can be redefined for class instances.
    </p>
    <p>
      Python Iterators: An iterator is an object that contains a countable
      number of values and can be iterated upon, meaning that we can traverse
      through all the values. Technically, in Python, an iterator is an object
      which implements the iterator protocol, which consist of the methods
      <code>__iter__()</code> and <code>__next__()</code>. The
      <code>for</code> loop actually creates an iterator object and executes
      the <code>next()</code> method for each loop.
    </p>
    <p>
      
    </p>
    <p>
      Here is a famous problem mentioned in Paul Graham's essay: We want to
      write a function that generates accumulators &ndash; a function that
      takes a number <span class="no-breaks"><img src="python-1.png" style="margin-left: -0.0124121212121212em; margin-bottom: -0.0248242424242424em; margin-right: -0.0124121212121212em; margin-top: -0.0263272727272728em; vertical-align: 0em; height: 0.496484848484848em"></img>,</span> and returns
      a function that takes another number <img src="python-2.png" style="margin-left: -0.0124121212121212em; margin-bottom: -0.0248242424242424em; margin-right: -0.0124121212121212em; margin-top: -0.0191272727272727em; vertical-align: 0em; height: 0.726109090909091em"></img> and returns
      accumulations each time it is invoked (each time, <img src="python-2.png" style="margin-left: -0.0124121212121212em; margin-bottom: -0.0248242424242424em; margin-right: -0.0124121212121212em; margin-top: -0.0191272727272727em; vertical-align: 0em; height: 0.726109090909091em"></img>
      is added to the previous result, starting from <span class="no-breaks"><img src="python-1.png"
      style="margin-left: -0.0124121212121212em; margin-bottom: -0.0248242424242424em; margin-right: -0.0124121212121212em; margin-top: -0.0263272727272728em; vertical-align: 0em; height: 0.496484848484848em"></img>).</span> Here is the Python code:
    </p>
    <pre class="verbatim" xml:space="preserve">
def Ac(n):
   class dd:
       def __init__(self,n):
           self.value = n
       def inc(self,i):
           self.value += i
           return self.value
       
   return dd(n).inc

ac = Ac(10)
print(ac(1), ac(2), ac(3))

class Ac:
    def __init__(self,n):
        self.value = n
    def __call__(self,i):
        self.value += i
        return self.value

ac = Ac(10)
print(ac(1),ac(2),ac(3))</pre>
    <p>
      Python 3 introduced the <code>nonlocal</code> keyword. Using this, the
      solution is:
    </p>
    <pre class="verbatim" xml:space="preserve">
def foo(n):
    def inc(x):
        nonlocal n
        n += x
        return n
    return inc

acc = foo(10)
print(acc(1)) # Output: 11
print(acc(2)) # Output: 13 </pre>
    <h3 id="auto-32">8.1.<span style="margin-left: 1em"></span>Subclass, inheritance<span style="margin-left: 1em"></span></h3>
    <p>
      A language feature would not be worthy of the name &ldquo;class&rdquo;
      if it does not support inheritance.
    </p>
    <pre class="verbatim" xml:space="preserve">
class Shape:
    def __init__(self, color):
        self.color = color
 
    def area(self):
        pass
 
class Circle(Shape):
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius
 
    def area(self):
        return 3.14 * self.radius ** 2</pre>
    <p>
      
    </p>
    <p>
      By default, all Python classes are the subclasses of the object class.
    </p>
    <p>
      
    </p>
    <h3 id="auto-33">8.2.<span style="margin-left: 1em"></span> Polymorphism<span style="margin-left: 1em"></span></h3>
    <p>
      Function Polymorphism
    </p>
    <p>
      Class Polymorphism
    </p>
    <p>
      Inheritance Class Polymorphism
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      The following is the automatic differentiation using backward (or
      reverse) method.
    </p>
    <pre class="verbatim" xml:space="preserve">
class Expression:
    def __add__(exp1, exp2):
        return Plus(exp1,exp2)
    def __mul__(exp1, exp2):
        return Multiply(exp1, exp2)
        
class Variable(Expression):
    def __init__(self,value):
        self.value = value
        self.partial = 0
    def evaluate(self):
        return self.value
    def derive(self,seed):
        self.partial += seed

class Plus(Expression):
    def __init__(self,exp1,exp2):
        self.a = exp1
        self.b = exp2
    def evaluate(self):
        return self.a.evaluate() + self.b.evaluate()
    def derive(self,seed):
        self.a.derive(seed)
        self.b.derive(seed)
        
class Multiply(Expression):
    def __init__(self,exp1,exp2):
        self.a = exp1
        self.b = exp2
    def evaluate(self):
        return self.a.evaluate() * self.b.evaluate()
    def derive(self,seed):
        self.a.derive(seed * self.b.evaluate())
        self.b.derive(seed * self.a.evaluate())

x = Variable(2)
y = Variable(3)
z = x * (x + y) + y * y
z.derive(1)
print(x.partial)  # dz/dx Output:  7
print(y.partial)  # dz/dy Output:  8</pre>
    <p>
      This simple example illustrates several important concepts:
    </p>
    <p>
      * Class, subclass, inheritance
    </p>
    <p>
      * Operator overloading
    </p>
    <p>
      * Polymorphism
    </p>
    <p>
      * Recursion
    </p>
    <h2 id="auto-34">9.<span style="margin-left: 1em"></span>Built-in data structure<span style="margin-left: 1em"></span></h2>
    <p>
      Python primitive data structures: list, tuple, set, dict, string.
    </p>
    <pre class="verbatim" xml:space="preserve">
L = [3, &quot;hello&quot;, 0.5] # list
t = (1,2,&quot;apple&quot;,3) # tuple
t =  1,2, &quot;apple&quot;,3  # tuple
s = {&quot;apple&quot;, &quot;banana&quot;, 1} #set
d = {&quot;a&quot;:1, &quot;b&quot;:2} #dict
st = &quot;hello&quot;</pre>
    <p>
      Examining the above codes, we can summarize the sytax for differnt data
      structure: (1) elements in the four data structures are all separated by
      commas; (2) lists are written with <strong>square-brackets</strong>,
      tuples are written with optional <strong>round-brackets</strong>, sets
      and dicts are written with <strong>curly-brackets</strong>; (3) a dict
      (or hash table) is a special set in which each element has two fields,
      key and value, which are separated by a colon.
    </p>
    <p>
      Lists and tuples are <strong>ordered</strong> collections and thus
      support <strong>indexing</strong> (i.e., subscriptable) whereas sets and
      dicts are <strong>unordered</strong> and do not support indexing. (You
      can loop through the set items using a for loop, or ask if a specified
      value is present in a set, by using the <tt>in</tt> keyword.)
    </p>
    <p>
      The primitive type <code>string</code> can also be considered a
      nontrivial data structure, which supports indexing, similar to a list.
    </p>
    <p>
      An object that supports item assignment is called a mutable object.
      Lists, sets and dictionaries are mutable. Strings and tuples are
      immutable. 
    </p>
    <h3 id="auto-35">9.1.<span style="margin-left: 1em"></span>List<span style="margin-left: 1em"></span></h3>
    <p>
      Since a list contains misc items, which are not just numbers, some
      operations on lists are different from array operations that we expect
      in an array Language. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [12]: a=[1,2,3]
In [13]: 2*a
Out[13]: [1, 2, 3, 1, 2, 3] #rather than doubling each element</pre>
    <p>
      Adding lists concatenates them, just as the &ldquo;<tt>+</tt>&rdquo;
      operator concatenates strings. The Python standard library defines an
      array type, which is still a list type, except that the type of objects
      stored in it is constrained to a single type. As a result, this array
      type is not as versatile, efficient, or useful as the NumPy array.
    </p>
    <p>
      List elements can be accessed by using indexes. Indexes of a list start
      from zero. Elements of a list can also be accessed by using negative
      index. For example <code>myList[-1]</code> refers to the last element of
      the list, and <code>myList[-2]</code> refers to the next-to-last element
      of the list, etc.
    </p>
    <p>
      We can use slicing notation to pick out a sublist, e.g., <code>b =
      myList[0:2]</code>. Python use the convention that the final element
      specified, i.e. <code>myList[2]</code> in this case, is not included in
      a list slice. If the upper and/or lower limit are omitted, the
      corresponding list limit will be used, e.g., <code>myList[:]</code>
      refers to the whole list.
    </p>
    <p>
      Nested lists (multidimensional lists, lists of lists) can be referenced
      by using multiply index, such as <code>myList[0][1]</code>, not
      <code>myList[0,1]</code>. The latter notation only works for
      <code>numpy</code> array objects.
    </p>
    <p>
      Python is an object-orientated language, and as such it uses classes to
      define data types, including its primitive types. A list object has some
      predefined methods. These methods are invoked as using dot notation,
      e.g., <code>instant.method(arg1,arg2,&hellip;)</code>. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
mylist.append('d') #will add 'd' to the list
mylist.pop(2) # will remove items by index, remove the 3rd item
mylist.remove(x) # Remove the first item from the list whose value is x.
mylist.index(x) #return the index of the first item whose value is x
mylist.count(x) # Return the number of times x appears
list.insert(i, x) #will insert an item before element with index i.
list2.extend(list2)</pre>
    <p>
      We can view all the methods defined for a object by using the built-in
      function <code>dir</code>. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
L = [] # define a list object
dir(L) # view all the methods of the list object</pre>
    <p>
      List Comprehensions
    </p>
    <p>
      A list comprehension consists of brackets containing an expression
      followed by a <code>for</code> clause, then zero or more
      <code>for</code> or <code>if</code> clauses. The result will be a new
      list resulting from evaluating the expression in the context of the
      <code>for</code> and <code>if</code> clauses. For example,
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; ls = [1, 2, -3, -4]
&gt;&gt;&gt; [math.sqrt(x) for x in ls if x&gt;0]
[1.0, 1.414]</pre>
    <p>
      The following code combines the elements of two lists if they are not
      equal:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</pre>
    <p>
      List comprehensions are more declarative than loops, which means they're
      easier to read and understand. Loops require you to focus on how the
      list is created. You have to manually create an empty list, loop over
      the elements, and add each of them to the end of the list. With a list
      comprehension in Python, you can instead focus on what you want to go in
      the list and trust that Python will take care of how the list
      construction takes place.
    </p>
    <h3 id="auto-36">9.2.<span style="margin-left: 1em"></span>String<span style="margin-left: 1em"></span></h3>
    <p>
      Single or double quotation marks are used to define a string value:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [17]: a = 'hello, world' # string
In [18]: a = &quot;hello, world&quot; # string</pre>
    <p>
      Each character in a string corresponds to an index and can be accessed
      using index notation (similar to a list). String methods:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = &quot;hello, world&quot; # string
a.split(&quot;,&quot;)  #Splits the string at the specified separator, and returns a list
a.find(&quot;o&quot;) #Searches the string for &quot;o&quot; and returns the position where it was found</pre>
    <p>
      Again, we can view all the methods defined for <code>string</code>
      object by using the built-in function <code>dir</code>. Note that all
      string methods returns new values. They do not change the original
      string.
    </p>
    <p>
      f-strings,
    </p>
    <h3 id="auto-37">9.3.<span style="margin-left: 1em"></span>Tuple<span style="margin-left: 1em"></span></h3>
    <p>
      Another data structure similar to list is tuple, which is an ordered
      collection of items separated by comman and (optionally) enclosed in
      round-brackets (parentheses):
    </p>
    <pre class="verbatim" xml:space="preserve">
t=(1,2,&quot;apple&quot;)</pre>
    <p>
      The round-brackets are optional. Slicing and addressing a tuple are
      similar to those of a list. Like a list, we can loop through the tuple
      items by using a <code>for</code> loop. Unlike a list,  Tuples are
      <strong>unchangeable</strong>. Once a tuple is created, we cannot change
      its values.
    </p>
    <p>
      Tuple methods
    </p>
    <pre class="verbatim" xml:space="preserve">
mytuble.count(&quot;apple&quot;) # Returns the number of times a specified value occurs in a tuple
mytuble.index(&quot;apple&quot;) # Searches the tuple for a specified value and returns the index</pre>
    <h3 id="auto-38">9.4.<span style="margin-left: 1em"></span>Dictionary<span style="margin-left: 1em"></span></h3>
    <p>
      A dictionary is a collection of a pair of items enclosed in curly
      brackets:
    </p>
    <pre class="verbatim" xml:space="preserve">
d={&quot;a&quot;:1, &quot;b&quot;:2} </pre>
    <p>
      each element has two filds, key and value, separated by :
    </p>
    <p>
      In other languages, this type may be called &ldquo;hashmaps&rdquo; or
      &ldquo;associative arrays&rdquo;.
    </p>
    <p>
      Dictionaries can be built up and added to in a straightforward manner:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [8]: d = {}
In [9]: d[&quot;last name&quot;] = &quot;Alberts&quot;
In [10]: d[&quot;first name&quot;] = &quot;Marie&quot;
In [11]: d[&quot;birthday&quot;] = &quot;January 27&quot;
In [12]: d
Out[12]: {'birthday': 'January 27', 'first name': 'Marie','last name': 'Alberts'}        </pre>
    <p>
      As shown above, the values in a dict can be referred to by using keys.
      The type of keys of a dictionary can be string, int, float, and even a
      tuple. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [15]: A={(1,2):4, &quot;b&quot;:5}
In [16]: A[(1,2)]
Out[16]: 4</pre>
    <p>
      It is interesting to note that referencing a dictionary item is very
      similar to referencing a list element if the keys are of int type.
    </p>
    <p>
      Properties and methods of a dict can be shown by using
      <code>dir(dict)</code>. Some examples:
    </p>
    <pre class="verbatim" xml:space="preserve">
d.keys() # return all the keys 
d.values() # return all the values
d.items() # return all the tuples (key,value)</pre>
    <h3 id="auto-39">9.5.<span style="margin-left: 1em"></span>Set<span style="margin-left: 1em"></span></h3>
    <p>
      You can think of sets in a technical sense, namely that they are
      unordered, unindexed, mutable, and contain unique (do not allow
      duplicate values) and hashable values.
    </p>
    <p>
      Think of sets as dictionaries without any values. Whatever applies to
      dict keys also applies to the elements of a set. A list can not be an
      element of a set because lists are unhashable.
    </p>
    <pre class="verbatim" xml:space="preserve">
a={&quot;dd&quot;, 1, (3,4)} #an items in set can be a tuple, but can not be a list</pre>
    <p>
      An object is hashable if it has a hash value which never changes during
      its lifetime (it needs a __hash__() method), and can be compared to
      other objects (it needs an __eq__() or __cmp__() method). Hashable
      objects which compare equal must have the same hash value.
    </p>
    <p>
      Hashability makes an object usable as a dictionary key and a set member,
      because these data structures use the hash value internally.
    </p>
    <p>
      All of Python's immutable built-in objects are hashable, while no
      mutable containers (such as lists or dictionaries) are. Objects which
      are instances of user-defined classes are hashable by default; they all
      compare unequal, and their hash value is their id().
    </p>
    <p>
      We can not access an item in a set by referring to an index, since sets
      are unordered and have no index. But we can loop through a set using
      <code>for</code> loop, or ask if a specified value is present in a set
      by using the <code>in</code> keyword.
    </p>
    <pre class="verbatim" xml:space="preserve">
myset = {&quot;apple&quot;, &lsquo;&lsquo;banana&quot;, &lsquo;&lsquo;cherry&quot;}
for x in myset:
    print(x)
print(&quot;banana&quot; in myset) #True</pre>
    <p>
      Some methods of the set object:
    </p>
    <pre class="verbatim" xml:space="preserve">
myset.add(&quot;apple&quot;) # adds an element to the set
myset.remove(&quot;apple&quot;) # removes a particular element from the set
myset.pop() # removes an random element from the set, retuns the removed item</pre>
    <p>
      Similar to list comprehension, there is set comprehension:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt;s = {v for v in 'abcdabcd' if v not in 'cb'}
&gt;&gt;&gt; print(s)
{'a', 'd'}</pre>
    <p>
      Summary of useage of various brackets in python:
    </p>
    <ul>
      <li>
        <p>
          square brackets <code>[]</code> are used in defining lists, list
          comprehensions, and for retriving elements from lists/tuple/dicts,
          where retriving can be indexing/slicing/lookup. In numpy, 
          <code>[]</code> are used for arrays.
        </p>
      </li>
      <li>
        <p>
          round brackets <code>()</code> are used in function
          definitions/calls, class instancination, generator expressions,
          defining order of operations, and tuples, where <code>()</code> can
          be omitted if there is no ambiguity.
        </p>
      </li>
      <li>
        <p>
          curly brackets <code>{}</code> are used in defining the two hash
          table types&ndash; dictionaries and sets, in performing string
          interpolation using &ldquo;f-strings&rdquo;
        </p>
      </li>
    </ul>
    <p>
      
    </p>
    <h2 id="auto-40">10.<span style="margin-left: 1em"></span>File Handling<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-41">10.1.<span style="margin-left: 1em"></span>Create file object<span style="margin-left: 1em"></span></h3>
    <p>
      Python builtin function <code>open()</code> takes two parameters;
      <em>filename</em>, and <em>mode</em>, and returns a file object. For
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
f = open('t.txt', 'r')</pre>
    <p>
      There are four different modes for opening a file:
    </p>
    <p>
      <code>&quot;r&quot;</code> - Read - Default value. error if the file
      does not exist.
    </p>
    <p>
      <code>&quot;a&quot;</code> - Append - Opens a file for appending,
      creates the file if it does not exist.
    </p>
    <p>
      <code>&quot;w&quot;</code> - Write - Opens a file for writing, creates
      the file if it does not exist
    </p>
    <p>
      <code>&quot;x&quot;</code> - Create - Creates the specified file,
      returns an error if the file exists
    </p>
    <p>
      In addition you can specify if the file should be handled as binary or
      text mode
    </p>
    <p>
      <code>&quot;t&quot;</code> - Text - Default value. 
    </p>
    <p>
      <code>&quot;b&quot;</code> - Binary - Binary mode
    </p>
    <h3 id="auto-42">10.2.<span style="margin-left: 1em"></span>Methods of file object<span style="margin-left: 1em"></span></h3>
    <p>
      A python file object has several predefined methods. To read a file, we
      can use its methods, such as <code>read</code>, <code>readline</code>,
      <code>readlines</code>. To write to a file, we can use
      <code>write</code>. However, <code>write</code> is limited to string
      data, which makes it inconventient to use in most cases. A more
      convenient way is to use <code>print</code> and use the file object as
      an argument:
    </p>
    <pre class="verbatim" xml:space="preserve">
print(&quot;This is x1: &quot;, x1, file=f)</pre>
    <p>
      More examples:
    </p>
    <pre class="verbatim" xml:space="preserve">
txt = f.read() #readin the entire file, return a string
f.close()
<pre class="verbatim" xml:space="preserve">f = open(&quot;t.txt&quot;, &quot;w&quot;)
f.write(&quot;hello&quot;) #write to the file
f.write(&quot;\n&quot;)
f.close() </pre>
f = open('t.txt', 'r')
txt1 = f.readline() #readin a line from the file, return a string
txt2 = f.readline() #readin another line
f.close()
f = open('t.txt', 'r')
txt = f.readlines() #read the entire file, return a list of string
#(one string=&gt;one line)</pre>
    <p>
      A file object can also be converted to a list:
    </p>
    <pre class="verbatim" xml:space="preserve">
f = open('t.txt', 'r')
a = list(f) # return a list, the same as a = f.readlines()</pre>
    <p>
      A file object is also an iterator, which means that we can loop over it:
    </p>
    <pre class="verbatim" xml:space="preserve">
f=open('t.txt', 'r')
for line in f:
    print(line, end='')</pre>
    <p>
      Besides builtin functions, there are lots of third-party libriaries for
      handling files. For reading/writing arrays from/to a file, we can use
      numpy function <code>np.loadtxt()</code> for reading and
      <tt>np.savetxt()</tt> for writing:
    </p>
    <pre class="verbatim" xml:space="preserve">
data = np.loadtxt('myfile.txt')
np.savetxt('myfile.txt', (x,y,z))
np.savetxt('myfile.txt', np.transpose([x,y,z]))
np.savetxt('myfile.txt', np.column_stack([x,y,z]))
np.savetxt('myfile.txt', np.c_[x,y,z])</pre>
    <p>
      For reading files, we can also use <tt>np.genfromtxt()</tt>, which is
      more flexible.
    </p>
    <h2 id="auto-43">11.<span style="margin-left: 1em"></span>With<span style="margin-left: 1em"></span></h2>
    <p>
      The <code>with</code> statement clarifies code that previously would use
      try&hellip;finally blocks to ensure that clean-up code is executed.
    </p>
    <pre class="verbatim" xml:space="preserve">
with expression [as variable]:
    with-block</pre>
    <p>
      The expression is evaluated, and it should result in an object that
      supports the context management protocol (that is, has
      <code>__enter__()</code> and <code>__exit__()</code> methods). This kind
      of objects are called context managers.
    </p>
    <p>
      The classic example is opening a file, manipulating the file, then
      closing it:
    </p>
    <pre class="verbatim" xml:space="preserve">
 with open('output.txt', 'w') as f:
     f.write('Hi there!')</pre>
    <p>
      The above <code>with</code> statement will automatically close the file
      after the nested block of code. The advantage of using a with statement
      is that it gaurantee that the file will be closed no matter how the
      nested block exits. If an exception occurs before the end of the block,
      it will close the file before the exception is caught by an outer
      exception handler. If the nested block were to contain a return
      statement, or a continue or break statement, the <code>with</code>
      statement would automatically close the file in those cases, too.
    </p>
    <h2 id="auto-44">12.<span style="margin-left: 1em"></span>Numpy<span style="margin-left: 1em"></span></h2>
    <p>
      NumPy is the reason why Python stands among the ranks of R, Matlab, and
      Julia, as one of the most popular languages for doing STEM-related
      computing. It is a third-party library (i.e. it is not part of Python's
      standard library) that facilitates numerical computing in Python by
      providing users with N-dimensional array objects for storing data, and
      mathematical functions for operating on them. NumPy makes use of a
      process known as vectorization, that enables a degree of computational
      efficiency that is otherwise unachievable by the Python language.
    </p>
    <p>
      Many libraries depend on NumPy's N-dimensional arrays. NumPy also
      fundamentally impacts the designs of these libraries and the way that
      they interface with their users.
    </p>
    <pre class="verbatim" xml:space="preserve">
import numpy as np</pre>
    <p>
      The n-dimensional array object in NumPy is called <code>ndarray</code>,
      all elements of which are of the same type. The data of a
      <code>ndarray</code> object are stored in contiguous block of system
      memory, which makes NumPy arrays efficient. 
    </p>
    <p>
      
    </p>
    <p>
      <code>ndarray</code> objects can be created by using various functions,
      such as <code>np.ndarray()</code>, <code>np.array()</code>,
      <code>np.zeros()</code> <code>np.empty()</code>,
      <code>np.linspace()</code>, <code>np.meshgrid()</code>,
      <code>np.mgrid[]</code>, <code>np.ogrid[]</code>. 
    </p>
    <p>
      <code>np.meshgrid</code> is modelled after Matlab's meshgrid command. I
      stick to using indexing='ij', which is less confusing than the case with
      indexing='xy'.
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; m = 4; n = 3;
&gt;&gt;&gt; x = np.linspace(1,4,m)
&gt;&gt;&gt; y = np.linspace(5,7,n)
&gt;&gt;&gt; xx, yy = np.meshgrid(x,y, indexing='ij')</pre>
    <p>
      Numpy has another function <tt>ix_</tt> that's similar to meshgrid:
    </p>
    <pre class="verbatim" xml:space="preserve">
xx, yy = np.ix_(x,y)</pre>
    <p>
      In this case, you get compact arrays that can be broadcasted between
      each other.
    </p>
    <p>
      Another family of methods of geting mesh-grid is to use <tt>mgrid</tt>
      and <tt>ogrid</tt>, which are instances that returns mesh-grid when
      idexed. The difference between them is that <tt>mgrid</tt> returns a
      dense (i.e., fleshed out) mesh-grid while <tt>ogrid</tt> returns compact
      one.
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; m=4;  n=3;
&gt;&gt;&gt; XX, YY = np.mgrid[1:4:m*1j, 5:7:n*1j]
&gt;&gt;&gt; XX
array([[1., 1., 1.],
       [2., 2., 2.],
       [3., 3., 3.],
       [4., 4., 4.]])
&gt;&gt;&gt; YY
array([[5., 6., 7.],
       [5., 6., 7.],
       [5., 6., 7.],
       [5., 6., 7.]])
# Here the shape of <code>XX</code> and <code>YY</code> is <code>(m,n)</code>. </pre>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; a, b = np.ogrid[1:4:m*1j, 5:7:n*1j]
&gt;&gt;&gt; a
array([[1.],
       [2.],
       [3.],
       [4.]])
&gt;&gt;&gt; b
array([[5., 6., 7.]])
&gt;&gt;&gt; XX, YY = np.broadcast_arrays(a,b)</pre>
    <p>
      <tt>mgrid</tt> and <tt>ogrid</tt> are less versatile than
      <tt>meshgrid</tt> in that they are limitted to uniform case and thus can
      not use arbitary grids (e.g. grids read from numerical files).
      <tt>mgrid</tt> and <tt>ogrid</tt> can be used to generate 1D grid, and
      can be used in place of linspace().
    </p>
    <p>
      
    </p>
    <p>
      Numpy is ensentially about vectorization (avoid explicit
      looping/indexing in python so that they can be done in C efficiently).
      As a result, we want to make relevant arrays be of the same shape or be
      able to be boradcasted between each other.
    </p>
    <p>
      When operating on two arrays, NumPy compares their shapes element-wise,
      starting with the trailing (i.e. rightmost) dimensions and works its way
      left. Two dimensions are compatible when they are equal, or one of them
      is 1. When broadcasting, arrays do not need to have the same number of
      dimensions.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      <code>ndarray.tolist()</code> Return a copy of the array data as a
      (nested) Python list.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      &ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;
    </p>
    <p>
      
    </p>
    <p>
      While a CPU-bound task is characterized by the computer's cores
      continually working hard from start to finish, an IO-bound job is
      dominated by a lot of waiting on input/output to complete.
    </p>
    <p>
      non-blocking function
    </p>
    <p>
      Over the last few years, a separate design has been more comprehensively
      built into CPython: asynchronous IO, enabled through the standard
      library's asyncio package and the new async and await language keywords.
      (async IO is not a newly invented concept, and it has existed or is
      being built into other languages and runtime environments, such as Go,
      C#, or Scala.)
    </p>
    <p>
      Async IO is not threading, nor is it multiprocessing. It is not built on
      top of either of these. In fact, async IO is a single-threaded,
      single-process design: it uses cooperative multitasking.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      &ndash;&ndash;&ndash;&ndash;-
    </p>
    <p>
      When developing this document, I read the following materials:
    </p>
    <p>
      https://docs.python.org/
    </p>
    <p>
      https://www.w3schools.com/python/
    </p>
    <p>
      https://physics.nyu.edu/pine/pymanual/html/
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <h2 id="auto-45">Bibliography<span style="margin-left: 1em"></span></h2>
    <div class="compact-block" style="text-indent: 0em">
      <font style="font-size: 84.0%"><dl>
        <p>
          <dt>
            <strong>[1]  </strong>
          </dt>
          <dd>
            <p>
              <a id="bib-TeXmacs:website"></a>J. van der Hoeven et al. GNU TeXmacs. <a href="https://www.texmacs.org"><tt>https://www.texmacs.org</tt></a>,
              1998.
            </p>
          </dd>
        </p>
      </dl></font>
    </div>
  </body>
</html>