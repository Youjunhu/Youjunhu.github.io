<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Programming in Python 3</title>
    <meta content="TeXmacs 2.1.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong>Programming in Python
            3</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Youjun Hu</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        Institute of Plasma Physics, Chinese Academy of
                        Sciences
                      </p>
                      <p>
                        Email: yjhu@ipp.cas.cn
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <p>
      
    </p>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>Introduction<span style="margin-left: 1em"></span></h2>
    <p>
      Python is an interpreted, object-oriented, high-level programming
      language with dynamic semantics. Its high-level built in data
      structures, combined with dynamic typing and dynamic binding, make it
      attractive for rapid application development, as well as for use as a
      scripting or glue language to connect existing components together.
    </p>
    <p>
      My primary use of Python is to read numerical data, analyze and
      visualize these data by using libraries <code>numpy</code> and
      <code>matplotlib</code>.
    </p>
    <p>
      Python is case sensitive.
    </p>
    <p>
      Python was designed for convenience and hence uses <strong>dynamically
      typed</strong> variables.
    </p>
    <p>
      Python is lexical scoped, like most contemporary programming languages.
    </p>
    <p>
      Python functions are first-class citizens, which means: they can be
      treated like any other variable, can be passed to a function, and can be
      returned from any other function.
    </p>
    <p>
      Python, like most languages, is multi-paradigm: object-oriented,
      procedural (imperative), and functional.
    </p>
    <p>
      Python's sytax emphasizes readability and therefore reduces the cost of
      program maintenance.
    </p>
    <p>
      Python uses indentation for statement grouping. Leading whitespace
      (spaces and tabs) at the beginning of a logical line is used to compute
      the indentation level of the line, which in turn is used to determine
      the grouping of statements (i.e. code blocks such as loops, branchings,
      function/class body). Indentation-based syntax is believed to enhances
      source code readability. Most programming languages use brackets for
      defining blocks (e.g., <code>C</code> and <code>Java</code> use
      curly-brackets, Lisp/Scheme uses round-brackets).
    </p>
    <p>
      A python statement can be delimited by a newline or semicolon. Therefore
      semicolon can be used to put multiple statements in the same line. This
      works only for some simples statements and does not work for compound
      statements (e.g., loop) due to the requirement of the layout syntax.
      Semicolons at the end of a Python command is not necessary, but if used,
      can suppress some output in interactive modes.
    </p>
    <p>
      Python tries to keep the number of keywords small and many things in
      practical programming are done by function calls, rather than keyword
      statements. For example, early terminating a script is by function
      calls, such as <code>exit()</code>, <code>sys.exit()</code>, and
      <code>quit()</code>.
    </p>
    <p>
      The reserved words (keywords) in Python are as follows.
    </p>
    <p>
      Value keywords: <code>True, False, None</code>
    </p>
    <p>
      Operator keywords: <code>and, or, not, in, is</code>
    </p>
    <p>
      Control flow keywords: <code>if, elif, else</code>, <code>for, while,
      break, continue, pass</code>, <code>return, yield</code>
    </p>
    <p>
      Structure keywords: <code>def, class, lambda, with, as</code>
    </p>
    <p>
      Variable handling keywords: <code>del, global, nonlocal</code>
    </p>
    <p>
      Import module keywords: <code>import, from, as</code>
    </p>
    <p>
      Exception-handling keywords: <code>try, except, raise, finally, else,
      with, assert</code>
    </p>
    <p>
      Asynchronous programming keywords: <code>async, await</code>
    </p>
    <p>
      The keywords <code>else</code> and <code>as</code> have additional uses
      beyond their initial use cases. The <code>else</code> keyword is used
      with conditionals and loops as well as with <code>try</code> and
      <code>except</code>. The <code>as</code> keyword is used in
      <code>import</code> as well as in the <code>with</code> keyword.
    </p>
    <p>
      Some identifiers are only reserved under specific contexts. These are
      known as soft keywords. The identifiers <code>match</code>,
      <code>case</code> and <code>_</code> can syntactically act as keywords
      in contexts related to the pattern matching statement, but this
      distinction is done at the parser level, not when tokenizing.
    </p>
    <p>
      A lexical analyzer breaks a file into tokens (a token is a string with
      an assigned and thus identified meaning). The stream of tokens generated
      by the lexical analyzer is then used as input to the parser.
    </p>
    <p>
      Comments in python: (1) anything after a hash (<code>#</code>) in a line
      is a comment. A comment signifies the end of the logical line unless the
      implicit line joining rules are invoked.  (2) triple quotes introduce
      string literals, which can have multiple-lines, and thus can serve as
      multiple-line comments.
    </p>
    <h2 id="auto-2">2<span style="margin-left: 1em"></span>Run Python program<span style="margin-left: 1em"></span></h2>
    <h4 id="auto-3">1<span style="margin-left: 1em"></span>Interactive mode<span style="margin-left: 1em"></span></h4>
    <p>
      In a Linux terminal, invoking <code>python</code> without any
      comand-line option will enter the interactive mode, where we can type
      python source code:
    </p>
    <pre class="verbatim" xml:space="preserve">
yj@pic:~$ python
&gt;&gt;&gt; 2 + 3
5</pre>
    <h4 id="auto-4">2<span style="margin-left: 1em"></span>Script file mode<span style="margin-left: 1em"></span></h4>
    <p>
      Create a Python script file <code>a.py</code> (by using any text
      editor):
    </p>
    <pre class="verbatim" xml:space="preserve">
x = &quot;World&quot;
print(&quot;Hello &quot; + x)</pre>
    <p>
      Then run it in a Linux terminal by specifying the interpreter and the
      script file:
    </p>
    <pre class="verbatim" xml:space="preserve">
python a.py</pre>
    <p>
      Another way (in Linux) is to specify the interpreter in the script file,
      such as:
    </p>
    <pre class="verbatim" xml:space="preserve">
#!/usr/bin/python3
x = &quot;World&quot;
print(&quot;Hello &quot; + x)</pre>
    <p>
      where the first line specifies the interpreter for the present script
      file. Then we give executable permission to this file:
    </p>
    <pre class="verbatim" xml:space="preserve">
chmod u+x a.py</pre>
    <p>
      And run it in a Linux terminal (assume that the file is in the present
      directory):
    </p>
    <pre class="verbatim" xml:space="preserve">
./a.py</pre>
    <h2 id="auto-5">3<span style="margin-left: 1em"></span>Use python module/library<span style="margin-left: 1em"></span></h2>
    <p>
      In Python, a plain text file containing Python code that is intended to
      be directly executed by the user is usually called script, which is an
      informal term that means top-level program file. On the other hand, a
      plain text file, which contains Python code that is designed to be
      imported and used from another Python file, is called module. Use
      <code>import</code> to get access to python  modules. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
import foo</pre>
    <p>
      Then python will look for a file with name being <code>foo.py</code>
      first in the current directory and then in other directories assumed by
      python. If the file is found, it will be loaded. Here <code>foo</code>
      is called module name. More examples: 
    </p>
    <pre class="verbatim" xml:space="preserve">
import numpy as np
import matplotlib.pyplot as plt</pre>
    <p>
      A module can contain executable statements as well as function
      definitions. These statements are intended to initialize the module.
      They are executed only the first time the module name is encountered in
      an import statement.
    </p>
    <p>
      Each module has its own private symbol table, which is used as the
      global symbol table by all functions defined in the module. Thus, the
      author of a module can use global variables in the module without
      worrying about accidental clashes with a user's global variables. A user
      of a module can access a module's global variables using
      <code>modname.itemname</code>, no matter the item is a function or
      regular variable.
    </p>
    <p>
      Modules can import other modules. It is customary but not required to
      place all import statements at the beginning of a module
    </p>
    <p>
      There is a variant of the import statement that imports names from a
      module directly into the importing module's symbol table. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
from numpy import sin</pre>
    <p>
      which import a specific function to the current namespace. Another form
      of <code>import</code> is
    </p>
    <pre class="verbatim" xml:space="preserve">
from math import *</pre>
    <p>
      This imports all names (except those beginning with an underscore)
      defined in the <code>math</code> package directly in the calling
      module's namespace. In most cases Python programmers do not use this
      form since it introduces an unknown set of names into the interpreter,
      possibly hiding some things you have already defined.
    </p>
    <h3 id="auto-6">3.1<span style="margin-left: 1em"></span>Install a new module<span style="margin-left: 1em"></span></h3>
    <p>
      Command tool <tt class="verbatim"><code>python3-pip</code></tt> can be used to
      install a new package. For example, in a linux terminal,
    </p>
    <pre class="verbatim" xml:space="preserve">
pip3 install numpy</pre>
    <p>
      will install the <code>numpy</code> package.
    </p>
    <h2 id="auto-7">4<span style="margin-left: 1em"></span>Objects, types, values, and name binding<span
    style="margin-left: 1em"></span></h2>
    <p>
      Objects are Python's abstraction for data. All data in a Python program
      is represented by objects or by relations between objects. Every object
      has an identity, a type, and a value. An object's identity never changes
      once it has been created; you may think of it as the object's address in
      memory. The <code>id()</code> function returns an integer representing
      its identity. The &lsquo;<code>is</code>' operator compares the identity
      of two objects; 
    </p>
    <p>
      An object's type determines the operations that the object supports and
      also defines the possible values for objects of that type. The
      <code>type()</code> function returns an object's type (which is an
      object itself). Like its identity, an object's type is also
      unchangeable.
    </p>
    <p>
      Some objects contain other objects; these are called containers.
      Examples of containers are tuples, lists, sets, and dictionaries.
    </p>
    <p>
      The value of some objects can change. Objects whose value can change are
      said to be mutable; objects whose value is unchangeable once they are
      created are called immutable. The value of an immutable container object
      that contains a mutable object can change when the latter's value is
      changed; however the container is still considered immutable, because
      the <code>id()</code> of its element are not changed. So, immutability
      is not strictly the same as having an unchangeable value. 
    </p>
    <p>
      An object's mutability is determined by its type; for instance, numbers,
      strings and tuples are immutable, while dictionaries and lists are
      mutable.
    </p>
    <p>
      For immutable types, operations that compute new values may actually
      return a reference to any existing object with the same type and value,
      while for mutable objects this is not allowed. E.g., after <code>a = 1;
      b = 1</code>, <code>a</code> and <code>b</code> may or may not refer to
      the same object with the value one, depending on the implementation, but
      after <code>c = []; d = []</code>, <code>c</code> and <code>d</code> are
      guaranteed to refer to two different, unique, newly created empty lists.
    </p>
    <p>
      All python's objects were based on a C data structure and its variations
      no matter the object is a simple object such as an integer, i.e.,
      primitive, or something more complicated such as a class.
    </p>
    <p>
      On high level of abstraction, concepts in python can be categorized into
      two concepts: names and objects. Names refer to objects. Names are
      usually called variables. A name is introduced by name binding
      operation, which binds the name to an object, i.e, naming the object.
      The following constructs bind names: assignments, class definitions,
      function definitions, formal parameters to functions, import statements,
      for loop header, a capture pattern in structural pattern matching.
    </p>
    <p>
      (The physical representation of a name is most likely a pointer, but
      that's simply an implementation detail. Name is actually an abstract
      notion at heart.)
    </p>
    <p>
      Objects have individuality, and multiple names can be bound to the same
      object. This is known as aliasing in some languages. Let us first
      discuss the most basic name binding operation&mdash;assignements. The
      Python assignment operator is <code>=</code>. Python assignment
      statements do not return values.  For example
    </p>
    <pre class="verbatim" xml:space="preserve">
a = 1
b = 1</pre>
    <p>
      Then <code>a</code> and <code>b</code> may or may not refer to the same
      object (this can be checked with the build-in function
      <code>id()</code>.)
    </p>
    <pre class="verbatim" xml:space="preserve">
a = []
b = []</pre>
    <p>
      Here two objects (empty lists) are created in memory, and are named as
      <code>a</code> and <code>b</code>, respectively. Therefore
      <code>a</code> and <code>b</code> refer to the different objects.
    </p>
    <pre class="verbatim" xml:space="preserve">
a = []
b = a</pre>
    <p>
      Here the second line give an alias to the object named <code>a</code>,
      rather than copying the objects. Therefore <code>a</code> and
      <code>b</code> refer to the same object.
    </p>
    <p>
      Python's built-in types include bool, numerics, sequences, mappings,
      classes, instances, and exceptions. Numeric types includes  int, float,
      and complex. Sequence types include list, tuple, string, and range.
      Mapping Types &mdash; dict,
    </p>
    <p>
      sets,
    </p>
    <p>
      Objects are never explicitly destroyed; however, when they become
      unreachable they may be garbage-collected. An implementation is allowed
      to postpone garbage collection or omit it altogether &mdash; it is a
      matter of implementation quality how garbage collection is implemented,
      as long as no objects are collected that are still reachable.
    </p>
    <h3 id="auto-8">4.1<span style="margin-left: 1em"></span>Argument unpacking<span style="margin-left: 1em"></span></h3>
    <p>
      Argument unpacking is the idea that a tuple can be split into several
      variables depending on the length of the sequence. For instance, you can
      unpack a tuple of two elements into two variables:
    </p>
    <pre class="verbatim" xml:space="preserve">
t = (2, 3)
a, b = t</pre>
    <p>
      In a for loop, argument unpacking can be used along the built-in zip(),
      which allows you to iterate through two or more sequences at the same
      time. On each iteration, zip() returns a tuple that collects the
      elements from all the sequences that were passed:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; first = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&gt;&gt;&gt; second = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
&gt;&gt;&gt; third = [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;]
&gt;&gt;&gt; for one, two, three in zip(first, second, third):
&hellip;     print(one, two, three)
&hellip;
a d g
b e h
c f i</pre>
    <p>
      More examples of argument unpacking (structured assignments):
    </p>
    <p>
      <code><p>
        a,b,c = 1,2,3
      </p><p>
        (a, (b,c)) = (10, (20,30))
      </p><p>
        [x,y] = [2,3]
      </p><p>
        a,b,c = 'Hey'
      </p><p>
        p, *q = &ldquo;Hello&rdquo; # q will refer to a list containing
        characters after &ldquo;H&rdquo;
      </p></code>
    </p>
    <p>
      This kind of structure assignments appear often in everyday coding, in a
      disguised way when  several variables are assigned with values of a
      function which returns multiply items. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)
fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(nrows=2, ncols=2)</pre>
    <p>
      Python adopts dynamical and strong typing system, where &ldquo;dynmical
      typing&rdquo; means type checking happens at run time.  In dynamically
      typed languages, typing is associated with the object that a variable
      refers to rather than the variable itself (a variable is a pointer
      pointing to the location where a value is stored). Therefor there is no
      type declaration for variables in dynamically typed languages. And a
      variable pointing to an object of a type can be later used to point to
      an object of another type.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <h2 id="auto-9">5<span style="margin-left: 1em"></span>Flow control<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-10">5.1<span style="margin-left: 1em"></span>Logical expressions<span style="margin-left: 1em"></span></h3>
    <p>
      Relation operators and logical operators in python are:
    </p>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">Equals</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid"><code>==</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Not Equals</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>!=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&lt;</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Less than or equal to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&lt;=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"> <code>&gt;</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Greater than or equal to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>&gt;=</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">Belongs to</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>in</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">object identity</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>is</code></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><div class="caption">
          <font style="font-size: 84.1%"><p>
            <b>Table 1. </b><a id="auto-11"></a>Relation operators
          </p></font>
        </div></td>
      </tr></tbody>
    </table>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-top: 1px solid">logical and</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-top: 1px solid"><code>and</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">logical or</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>or</code></td>
          </tr><tr>
            <td style="border-right: 1px solid; border-bottom: 1px solid; border-left: 1px solid">logicl not</td>
            <td style="border-right: 1px solid; border-bottom: 1px solid"><code>not</code></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
      </tr><tr>
        <td style="text-align: center; padding-left: 0em; padding-right: 0em"><div class="caption">
          <font style="font-size: 84.1%"><p>
            <b>Table 2. </b><a id="auto-12"></a>Logical operators
          </p></font>
        </div></td>
      </tr></tbody>
    </table>
    <p>
      The returned values by the above operators are of logical type (also
      called bool). (Logical type is a subclass of int.) Logical expressions
      can be used in several ways, most commonly in conditionals and loops.
    </p>
    <h3 id="auto-13">5.2<span style="margin-left: 1em"></span>Conditionals<span style="margin-left: 1em"></span></h3>
    <p>
      Python <code>if</code> structure takes the following form:
    </p>
    <pre class="verbatim" xml:space="preserve">
if a==0:
    print(&quot;a is zero&quot;)
elif a&lt;0:
    print(&quot;a is negative&quot;)
else:
    print(&quot;a is positive&quot;)</pre>
    <p>
      The blocks in a <code>if</code> structur does not introduce a new scope.
      Therefore, if new variables are defined in the blocks, they are still
      visible outside the <code>if</code> structure.
    </p>
    <p>
      One-line <code>if</code> structure:
    </p>
    <pre class="verbatim" xml:space="preserve">
if a &gt; b: print(&quot;a is greater than b&quot;)</pre>
    <p>
      If you have only one statement to execute, one for if, and one for else,
      you can put it all on the same line:
    </p>
    <pre class="verbatim" xml:space="preserve">
print(&quot;A&quot;) if a &gt; b else print(&quot;B&quot;)</pre>
    <p>
      The advantage of one-line <code>if</code> structure is that we can pass
      the return value seamlessly to other operation (functional style). For
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
abs_a = (a if a&gt;=0 else -a)</pre>
    <p>
      Another usage of the one-line  <code>if</code> structure is in the list
      comprehension:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
&gt;&gt;&gt; prices = [i if i &gt; 0 else 0 for i in original_prices]
&gt;&gt;&gt; prices
[1.25, 0, 10.22, 3.78, 0, 1.16]</pre>
    <h3 id="auto-14">5.3<span style="margin-left: 1em"></span>Loop structure<span style="margin-left: 1em"></span></h3>
    <p>
      Python has two primitive loops: <code>while</code> loop and
      <code>for</code> loop.
    </p>
    <pre class="verbatim" xml:space="preserve">
i = 1 # while-loop requires relevant variables to be ready
while i &lt; 6:
     print(i)
     i = i + 1</pre>
    <p>
      The above <code>while</code> loop is quite similar to those in Fortran
      and C.
    </p>
    <p>
      Another python loop structure is the <code>for</code> loop, which is
      used for iterating over a <strong>sequence</strong> (that is either a
      list, a tuple, a dictionary, a set, or a string)
    </p>
    <pre class="verbatim" xml:space="preserve">
for x in sequence:
    body</pre>
    <p>
      The above <code>for</code> loop is less like the <code>for</code> loop
      in C programming language, which looks like the following:
    </p>
    <pre class="verbatim" xml:space="preserve">
for(i=start; i&lt;some_threthod; some_operation_modifying_i) {loop_body}</pre>
    <p>
      which is essentially a <code>while</code> loop discussed above.
    </p>
    <p>
      Python for-loop is collection based loop, which means it is always used
      in combination with an iterable object, like a list or a range. With
      python <code>for</code> loop, we can execute a set of statements, once
      for each item in a sequence. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
for  x in fruits:
    print(x)</pre>
    <pre class="verbatim" xml:space="preserve">
for x in range(0, 3):
    print(x)</pre>
    <p>
      <code>continue</code> and <code>break</code> are similar to
      <code>cycle</code> and <code>exit</code> of Fortran and can be used in
      both <code>while</code> and <code>for</code> structures.
    </p>
    <p>
      In the above, <code>x</code> acts as a dummy variable, which does not
      need to be defined before the loop. The <code>for</code> loop does not
      form a new scope. This means that the variable <code>x</code> is
      acessible outside the loop. On exist from the <code>for</code> loop, the
      value of <code>x</code> is equal to the value got from the last
      iteration. If <code>x</code> is defined before the <code>for</code>
      loop, its value will be modified by the <code>for</code> loop.
    </p>
    <p>
      Note that the keyword <code>in</code> is used in Python for two
      different purposes: (1) The <code>in</code> keyword is used to check if
      a value is present in a sequence (list, range, string etc.). (2) The
      <code>in</code> keyword is also used to iterate through a sequence in a
      <code>for</code> loop.
    </p>
    <p>
      The advantage of collection-based iteration is that it helps avoid the
      off-by-one error that is common in other programming languages.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      Nested loops:
    </p>
    <pre class="verbatim" xml:space="preserve">
list_of_lists = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]
for list in list_of_lists:
    for x in list:
        print(x)</pre>
    <p>
      The <code>with</code> statement clarifies code that previously would use
      try&hellip;finally blocks to ensure that clean-up code is executed. The
      with statement is a control-flow structure whose basic structure is:
    </p>
    <pre class="verbatim" xml:space="preserve">
with expression [as variable]:
    with-block</pre>
    <p>
      The expression is evaluated, and it should result in an object that
      supports the context management protocol (that is, has
      <code>__enter__()</code> and <code>__exit__()</code> methods).
    </p>
    <p>
      The classic example is opening a file, manipulating the file, then
      closing it:
    </p>
    <p>
      
    </p>
    <pre class="verbatim" xml:space="preserve">
 with open('output.txt', 'w') as f:
     f.write('Hi there!')</pre>
    <p>
      The above with statement will automatically close the file after the
      nested block of code. The advantage of using a with statement is that it
      gaurantee that the file will be closed no matter how the nested block
      exits. If an exception occurs before the end of the block, it will close
      the file before the exception is caught by an outer exception handler.
      If the nested block were to contain a return statement, or a continue or
      break statement, the with statement would automatically close the file
      in those cases, too.
    </p>
    <p>
      
    </p>
    <h2 id="auto-15">6<span style="margin-left: 1em"></span>Function<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-16">6.1<span style="margin-left: 1em"></span>Define and call a function<span style="margin-left: 1em"></span></h3>
    <p>
      Use keyword <code>def</code> to define a function. The syntax is as
      follows:
    </p>
    <pre class="verbatim" xml:space="preserve">
def func_name ( arg1, arg2, argN ):
    some_codes
    return something</pre>
    <p>
      The function name follows the keyword <code>def</code>. Then the list of
      parameters, a colon, and a newline follow. Increase indent, the body of
      the function definition starts (use <code>return</code> to return
      value). Going back to the original indent terminates the function
      definition. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
def sum(ls):
    s = 0
    for x in ls:
        s = s + x
    return s</pre>
    <p>
      Call a function:
    </p>
    <pre class="verbatim" xml:space="preserve">
sum([1,2,3]) # call the function defined above, the result is 6
a = sum([1,2,3]) #call the function and assign the returned value to a variable</pre>
    <p>
      Functions can return multiple items:
    </p>
    <pre class="verbatim" xml:space="preserve">
def func():
    return 'a', 3, (1,2,3)  # returns a tuple of 3 elements (str, int, tuple)
x1, x2, x3 = func()  # unpacks the tuple of 3 elements into 3 vars
# x1: 'a'
# x2: 3
# x3: (1,2,3)</pre>
    <h3 id="auto-17">6.2<span style="margin-left: 1em"></span>Arguments are passed by assignment<span
    style="margin-left: 1em"></span></h3>
    <p>
      Some languages (e.g. Fortran) handle function arguments as references to
      existing variables, which is known as pass by reference. Other languages
      (e.g. C) handle them as independent values, an approach known as pass by
      value.
    </p>
    <p>
      Python assigns a unique identifier to each object and this identifier
      can be found by using Python's built-in <code>id()</code> function. It
      is ready to verify that actual and formal arguments in a function call
      have the same id value, which indicates that the dummy argument and
      actual argument refer to the same object.
    </p>
    <p>
      Note that the actual argument and the corresponding dummy argument are
      two names referring to the same object. If you re-bind a dummy argument
      to a new value/object in the function scope, this does not effect the
      fact that the actual argument still points to the original object
      because actual argument and dummy argument are two names.
    </p>
    <p>
      The above two facts can be summarized as &ldquo;arguments are passed by
      assignment&rdquo;, i.e., 
    </p>
    <pre class="verbatim" xml:space="preserve">
dummy_argument = actual_argument</pre>
    <p>
      If you re-bind dummy_argument to a new object in the function body, the
      <code>actual_argument</code> still refers to the original object. If you
      use <code>dummy_argument[0] = some_thing</code>, then this will also
      modify <code>actual_argument[0]</code>. Therefore the effect of
      &ldquo;pass by reference&rdquo; can be achieved by modifying the
      components/attributes of the object reference passed in. Of course, this
      requires that the object passed is a mutable object.
    </p>
    <p>
      To make comparison with other languages, you can say Python passes
      arguments by value in the same way as C does, where when you pass
      &quot;by reference&quot; you are actually passing by value the reference
      (i.e., the pointer)
    </p>
    <p>
      In practical programming, returning multiple values from functions is
      usually better than employing the effect of passing by reference.
    </p>
    <p>
      
    </p>
    <h3 id="auto-18">6.3<span style="margin-left: 1em"></span>Arguments packing and unpacking<span style="margin-left: 1em"></span></h3>
    <p>
      A formal argument (dummy argument), which appear in a function
      defintion, is often referred to as &ldquo;parameter&rdquo;. The actual
      argument, which appears in a function call, is often referred to as
      &ldquo;argument&rdquo;. When seeing the word &ldquo;argument&rdquo;, we
      need to judge from the contex whether it refers to a formal argument or
      actual argument.
    </p>
    <p>
      Besides standard positional arguments, there is a special formal
      argument that can accept a group of positional arguments and pack them
      into a single iterable object:
    </p>
    <pre class="verbatim" xml:space="preserve">
def my_sum(*args):
    result = 0
    for x in args:
        result += x
    return result

print(my_sum(1, 2, 3))</pre>
    <p>
      Here my_sum() takes all the parameters that are provided in the input
      and packs them all into a single iterable object (named
      <code>args</code> in this case). The name <code>args</code> does not
      mather. All that matters here is that you use the unpacking operator (*)
      before <code>args</code>.
    </p>
    <p>
      
    </p>
    <p>
      **kwargs works just like *args, but instead of accepting positional
      arguments it accepts keyword (or named) arguments. (Like args, kwargs is
      just a name that can be changed to whatever you want. Again, what is
      important here is the use of the unpacking operator **.) Take the
      following example:
    </p>
    <pre class="verbatim" xml:space="preserve">
# concatenate.py
def concatenate(**kwargs):
    result = &quot;&quot;
    # Iterating over the Python kwargs dictionary
    for arg in kwargs.values():
        result += arg
    return result

print(concatenate(a=&quot;Real&quot;, b=&quot;Python&quot;, c=&quot;Is&quot;, d=&quot;Great&quot;, e=&quot;!&quot;))</pre>
    <p>
      Note that in the example above the iterable object is a standard dict.
      If you iterate over the dictionary and want to return its values, like
      in the example shown, then you must use kwargs.values().
    </p>
    <p>
      To recap, in a function defintion, use *args and **kwargs to accept a
      changeable number of positional arguments and keyword argument,
      respectively.
    </p>
    <p>
      What if you want to create a function that takes a changeable number of
      both positional and named arguments (keyword arguments)?
    </p>
    <p>
      In this case, you have to bear in mind that order counts. Just as
      non-default arguments have to precede default arguments, so *args must
      come before **kwargs.
    </p>
    <p>
      To recap, the correct order for your parameters is:
    </p>
    <ol>
      <li>
        <p>
          Standard arguments
        </p>
      </li>
      <li>
        <p>
          *args arguments
        </p>
      </li>
      <li>
        <p>
          **kwargs arguments
        </p>
      </li>
    </ol>
    <p>
      You are now able to use *args and **kwargs to define Python functions
      that take a varying number of input arguments. Let's go a little deeper
      to understand something more about the unpacking operators.
    </p>
    <p>
      The single asterisk operator * can be used on any iterable that Python
      provides, while the double asterisk operator ** can only be used on
      dictionaries.
    </p>
    <p>
      starred expression
    </p>
    <p>
      
    </p>
    <p>
      The most straightforward way to pass arguments to a Python function is
      with positional arguments (also called required arguments).
    </p>
    <p>
      the parameters given in the function definition are referred to as
      formal parameters, and the arguments in the function call are referred
      to as actual parameters.
    </p>
    <p>
      Positional arguments must agree in order and number with the parameters
      declared in the function definition.
    </p>
    <p>
      Keyword arguments must agree with declared parameters in number, but
      they may be specified in arbitrary order.
    </p>
    <p>
      Default parameters allow some arguments to be omitted when the function
      is called.
    </p>
    <p>
      
    </p>
    <p>
      Things can get weird if you specify a default parameter value that is a
      mutable object.
    </p>
    <p>
      In Python, default parameter values are defined only once when the
      function is defined (that is, when the def statement is executed). The
      default value isn't re-defined each time the function is called.
    </p>
    <p>
      
    </p>
    <p>
      When a parameter name in a Python function definition is preceded by an
      asterisk (*), it indicates argument tuple packing. Any corresponding
      arguments in the function call are packed into a tuple that the function
      can refer to by the given parameter name. Any name can be used, but
      <code>args</code> is so commonly chosen that it's practically a
      standard.
    </p>
    <p>
      
    </p>
    <p>
      An analogous operation is available on the other side of the equation in
      a Python function call. When an argument in a function call is preceded
      by an asterisk (*), it indicates that the argument is a tuple that
      should be unpacked and passed to the function as separate values.
      Although this type of unpacking is called tuple unpacking, it doesn't
      only work with tuples. The asterisk (*) operator can be applied to any
      iterable in a Python function call.
    </p>
    <p>
      
    </p>
    <p>
      Argument Dictionary Packing
    </p>
    <p>
      Python has a similar operator, the double asterisk (**), which can be
      used with Python function parameters and arguments to specify dictionary
      packing and unpacking. Preceding a parameter in a Python function
      definition by a double asterisk (**) indicates that the corresponding
      arguments, which are expected to be <code>key=value</code> pairs, should
      be packed into a dictionary.
    </p>
    <p>
      
    </p>
    <p>
      Argument dictionary unpacking is analogous to argument tuple unpacking.
      When the double asterisk (**) precedes an argument in a Python function
      call, it specifies that the argument is a dictionary that should be
      unpacked, with the resulting items passed to the function as keyword
      arguments. Think of *args as a variable-length positional argument list,
      and **kwargs as a variable-length keyword argument list.
    </p>
    <p>
      
    </p>
    <p>
      The bare variable argument parameter * indicates that there aren't any
      more positional parameters. This behavior generates appropriate error
      messages if extra ones are specified. It allows keyword-only parameters
      to follow.
    </p>
    <p>
      To designate some parameters as positional-only, you specify a bare
      slash (/) in the parameter list of a function definition. Any parameters
      to the left of the slash (/) must be specified positionally.
    </p>
    <p>
      The positional-only and keyword-only designators may both be used in the
      same function definition
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; # This is Python 3.8
&gt;&gt;&gt; def f(x, y, /, z, w, *, a, b):
&hellip;     print(x, y, z, w, a, b)
&hellip;

&gt;&gt;&gt; f(1, 2, z=3, w=4, a=5, b=6)
1 2 3 4 5 6

&gt;&gt;&gt; f(1, 2, 3, w=4, a=5, b=6)
1 2 3 4 5 6</pre>
    <p>
      In this example:
    </p>
    <p>
      
    </p>
    <p>
      x and y are positional-only.
    </p>
    <p>
      a and b are keyword-only.
    </p>
    <p>
      z and w may be specified positionally or by keyword.
    </p>
    <p>
      
    </p>
    <p>
      Use the <code>yield</code> keyword to send values back to the caller.
      When you call a function that contains a yield statement anywhere, you
      get a generator object, but no code runs. Then each time you extract an
      object from the generator, Python executes code in the function until it
      comes to a yield statement, then pauses and delivers the object. When
      you extract another object, Python resumes just after the yield and
      continues until it reaches another yield (often the same one, but one
      iteration later). This continues until the function runs off the end, at
      which point the generator is deemed exhausted
    </p>
    <h3 id="auto-19">6.4<span style="margin-left: 1em"></span>Namespace and Scope<span style="margin-left: 1em"></span></h3>
    <p>
      A namespace is a mapping from names to objects. Most namespaces are
      currently implemented as Python dictionaries.
    </p>
    <p>
      The important thing to know about namespaces is that there is absolutely
      no relation between names in different namespaces; for instance, two
      different modules may both define a function maximize without confusion
      &mdash; users of the modules must prefix it with the module name.
    </p>
    <p>
      The local namespace for a function is created when the function is
      called, and deleted when the function returns or raises an exception
      that is not handled within the function.
    </p>
    <p>
      Of course, recursive invocations each have their own local namespace.
    </p>
    <p>
      
    </p>
    <p>
      A scope is a textual region of a Python program where a namespace is
      directly accessible. &ldquo;Directly accessible&rdquo; here means that
      you do not need to qualified the name with namespace name being suffix,
      i.e., you can directly use the name itself to access its refereence.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      A variable defined inside a function's body is known as a local
      variable. Formal arguments identifiers also behave as local variables. A
      variable created outside of functions is known as a global variable,
      which can be called a free variable from the perspective of a function.
    </p>
    <p>
      Python adopts the lexical scope, which means the binding of a free
      variable inside a function can be infered without considering where the
      function is called (but the value of the free variable can depend on
      where the function is called because the value of the free variable can
      be modified somewhere). 
    </p>
    <p>
      Compared with statically typed languages, the scope of a variable in a
      dynamically typed language like python becomes a little subtle. If a
      variable is <strong>assigned</strong> a value anywhere within the
      function's body, it's assumed to be a <strong>local</strong> unless
      explicitly declared as <code>global</code> or <code>nonlocal</code>.
    </p>
    <p>
      Therefore, to update a global variable inside a function, we need to
      declare it as global using <code>global</code> key word. If not using
      <code>global</code> keyword, a variable will be considered as a local
      variable if there is an assignment statement to the variable somewhere
      in the body. The locality of the variable will apply before the
      assignment creating the local variable, and thus if we use it before the
      assignment, we will get the UnboundLocalError: local variable 'x&rdquo;
      referenced before assignment.
    </p>
    <p>
      In a nested scope, we can use keyword <code>nonlocal</code> to declare
      that a variable is from enclosing scopes (scopes enclosing the present
      scope) but not a global. In other words, <code>nonlocal</code> means
      &ldquo;not a global or a local variable&rdquo;.
    </p>
    <p>
      The order in which Python looks up names is as follows. If you reference
      a given name, then Python will look that name up sequentially in the
      Local, Enclosing, Global, and Built-in namespaces. If the name exits,
      then you'll get the first occurrence of it. Otherwise, you'll get an
      error. This rull is often called LEGB rule.
    </p>
    <p>
      What is the relationship between scope and namespaces in Python?
    </p>
    <p>
      The terms, namespace and scope, can be used almost interchangeably
      because they overlap a lot in what they imply. A namespace is a
      dictionary, mapping names (as strings) to values. When you make a
      reference, like <code>print(a)</code>, Python looks through a list of
      namespaces to try and find one with the name as a key.
    </p>
    <p>
      A scope defines which namespaces will be looked in and in what order.
      The scope of any reference always starts in the local namespace, and
      moves outwards until it reaches the module's global namespace, before
      moving on to the builtins (the namespace that references Python's
      predefined functions and constants, like <code>range</code> and
      <code>getattr</code>), which is the end of the line.
    </p>
    <p>
      When we say x is in a function's namespace, we mean it is defined there,
      locally within the function. When we say x is in the function's scope,
      we mean x is either in the function's namespace or in any of the outer
      namespaces that the function's namespace is nested inside.
    </p>
    <p>
      Whenever you define a function (using <code>def</code> or
      <code>lambda</code>), you create a new namespace and a new scope. The
      namespace is the new, local hash of names. The scope is the implied
      chain of namespaces that starts at the new namespace, then works its way
      through any outer namespaces (outer scopes), up to the global namespace
      (the global scope), and on to the builtins.
    </p>
    <p>
      A scope refers to a region of a program from where a namespace can be
      accessed without a prefix.
    </p>
    <p>
      Classes in Python do not introduce a new namespace, which is why class
      attributes must be qualified with the class name and why instance
      attributes must be qualified with the instance name. 
    </p>
    <p>
      Lexical scoping:
    </p>
    <pre class="verbatim" xml:space="preserve">
x = 1
def myfun():
    return x
x = 10
myfun()  # return 10 </pre>
    <p>
      Q: Is the above behavior consistent with lexical scoping?
    </p>
    <p>
      Q.Yes, it is. myfun is using the x variable from the environment where
      it was defined, but that x variable now holds a new value. Lexical
      scoping means functions resovle variables from the scope where they were
      defined, but it doesn't mean they have to take a snapshot of the values
      of those variables at the time of function definition. The code line
      <code>x = 1</code> can be dropped and the codes are still valid, i.e.,
      <code>x</code> can be un-bound when the function is defined.
    </p>
    <p>
      Lexical scoping means functions resolve free variables from the scope
      where they were defined, not from the scope where they are called.
    </p>
    <p>
      The automatic destruction of unreferenced objects is called garbage
      collection.
    </p>
    <p>
      
    </p>
    <p>
      The nonlocal statement causes corresponding names to refer to previously
      bound variables in the nearest enclosing function scope. SyntaxError is
      raised at compile time if the given name does not exist in any enclosing
      function scope.
    </p>
    <p>
      A global statement cause corresponding name to refer to the name in the
      global scope (create the binding in the global scope if there is a name
      binding for that name in the local scope).
    </p>
    <h3 id="auto-20">6.5<span style="margin-left: 1em"></span>Nested function, return function as value,
    closure<span style="margin-left: 1em"></span></h3>
    <p>
      In Python, we can define a function inside the body of a function
      definition (function inside function, nested function). The inner
      functions have access to all outer variables in the enclosing functions.
      The inner functions can be called in the body of the enclosing function
      body. This feature is commonplace and can be found in most languages.
      What is interesting is that the inner function can be returned as the
      return value of the enclosing function. This feature is only available
      in languages that treat function as a first citizen. For example
    </p>
    <pre class="verbatim" xml:space="preserve">
def power_factory(exp):
    def power(base):
        return base ** exp
    return power

square = power_factory(2)
square(10)  #give 100
cube = power_factory(3)
cube(10) #give 1000</pre>
    <p>
      Variables like <code>exp</code> in the inner fucntion are called free
      variables. They are variables that are used in a code block but not
      defined there. When you return the inner function as the return value of
      the enclosing function, python needs to remember the values of these
      free variables (otherwise the returned function is meaningless). In
      other words, when you handle a nested function as value, the inner
      function are packaged together with the environment in which they
      execute. The resulting object is known as a closure. In other words, a
      closure is an inner function that carries information about its
      enclosing scope, even though its ecnclosing scope has completed its
      execution.
    </p>
    <p>
      Another famous example of making use of closure is to generate the
      derivative function of a given function:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; def derivative(f, dx):
        def prime(x):
            return (f(x+dx)-f(x))/dx
        return prime
&gt;&gt;&gt; dx=0.01
&gt;&gt;&gt; mycos=derivative(math.sin,dx)
&gt;&gt;&gt; mycos(2.0)</pre>
    <p>
      
    </p>
    <h3 id="auto-21">6.6<span style="margin-left: 1em"></span>Function call vs keyword structure<span
    style="margin-left: 1em"></span></h3>
    <p>
      Arguments in a function call are enclosed in round-brackets whereas
      arguments to a keyword statement are usually provided without
      round-brackets. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
x=1
del x</pre>
    <p>
      where <code>del</code> is a keyword statement and thus its argument
      <code>x</code> is not enclosed by round-brackets. In Python3,
      <code>print</code> becomes a function (in python2, it is a keyword
      statement). Therefore, arguments to python3 print must be enclosed by
      round-brackets:
    </p>
    <pre class="verbatim" xml:space="preserve">
print(&quot;hello&quot;)</pre>
    <p>
      In Python3, <code>exec</code> is a build-in function (rather than a
      keyword) and thus must be called with parentheses:
    </p>
    <pre class="verbatim" xml:space="preserve">
exec(&quot;x=12*7&quot;)</pre>
    <p>
      Similar to <code>exec</code>, <code>eval</code> is a build-in function,
      which evaluates an expression given as a string:
    </p>
    <pre class="verbatim" xml:space="preserve">
eval(&quot;1+2&quot;)</pre>
    <p>
      The difference between <code>exec</code> and <code>eval</code> is that
      <code>eval</code> returns a value while <code>exec</code> does not.
      <code>eval</code> can not be used for statements (such as assignment)
      while <code>exec</code> can be used for both statements and expressions.
    </p>
    <p>
      Statements are different from expressions in that statements do not
      return results and are executed solely for their side effects, while
      expressions always return a result and often do not have side effects at
      all.
    </p>
    <h3 id="auto-22">6.7<span style="margin-left: 1em"></span>Built-in functions and library
    functions<span style="margin-left: 1em"></span></h3>
    <p>
      Complete list of python built-in functions can be found at <a href="https://docs.python.org/3/library/functions.html">https://docs.python.org/3/library/functions.html</a>.
      As an example of useful built-in functions, <code>dir()</code>, without
      arguments, return the list of names in the current local scope. With an
      argument, <code>dir</code> attempt to return a list of attributes and
      methods for that object.
    </p>
    <p>
      Unlike <code>Fortran</code>, mathematical functions like
      <code>sin</code> and <code>cos</code> are not built-in functions of
      Python interpreter. These functions are defined in <code>math</code>
      module. To use them:
    </p>
    <pre class="verbatim" xml:space="preserve">
import math
math.sin(1.0)</pre>
    <p>
      Usually I prefer to use mathematical functions defined in
      <code>numpy</code> module, which are usually more powerful than their
      counterparts in <code>math</code> module. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [5]: import numpy as np
In [7]: a = [1,2,3] #define a list
In [8]: np.sin(a)
Out[8]: array([0.84147098, 0.90929743, 0.14112001])
In [9]: math.sin(a)
TypeError: must be real number, not list</pre>
    <h2 id="auto-23">7<span style="margin-left: 1em"></span>Class<span style="margin-left: 1em"></span></h2>
    <p>
      Class concept is a way of bundling data and functionality together, and
      supporting extention (i.e., inheritance). Define a new class define a
      new type of object, allowing new instances of that type to be created. A
      class is a blueprint for the instances of that type. The process of
      creating the object of that type is called instantiation.
    </p>
    <p>
      Compared with other programming languages, Python introduces class
      concepts with a minimum of new syntax and semantics. The following is a
      typical defintion of a class:
    </p>
    <pre class="verbatim" xml:space="preserve">
class ComplexNumber:
    scale = 1
    def __init__(self, r=0, i=0):
        self.real = r
        self.imag = i
    def show(self):
        print(f'{self.real}+{self.imag}j')
        print(f'scale={self.scale}')</pre>
    <p>
      The above define a class named <code>ComplexNumber</code>, with two
      methods and three attributes named <code>scale</code>,
      <code>real</code>, and <code>imag</code>.
    </p>
    <p>
      In practice, the statements inside a class definition will usually be
      function definitions. The function definitions inside a class must
      follow a peculiar form of argument list: The first dummy argument of a
      method is assumed by Python to be the object in question. The dummy
      object name is usually called <code>self</code>. This name is just a
      user convention: you can use an arbitry name here (i.e., what matters is
      its position in the argument list, not its name). We will follow this
      convention. (When the method is called, users must omit the object name
      from the argument list, and the name is figured out and inserted to the
      argument list by python behind the scene.)
    </p>
    <p>
      In a method, attributes of a class instance are created or referred to
      by using the dot notation: <code>self.attribute</code>. In the above,
      <code>self.real</code> and <code>self.imag</code> are attributes of an
      instance, whereas <code>scale</code> is an attribute of the class. Note
      that, if the usual scoping rule applies (i.e., the class defintion forms
      a parent scope for its methods), the attribute <code>scale</code> should
      be assessible in the method by using the name <code>scale</code>. It
      turns out we can refer to <code>scale</code> but must use a different
      name: the attribute must be qualified with the class name, i.e.,
      <code>ComplexNumber.scale</code>.
    </p>
    <p>
      This indicates that the scope of names defined in a class block is
      limited to the class block. It does not extend to the code blocks of
      methods. This is one of the new rules introduced to facilitate class
      defintion, i.e., class defintion body is not used as a parent scope for
      methods.  Otherwise, it would make class inheritance confusing: e.g., a
      method inherited by a subclass would have access to the subclass scope.
    </p>
    <p>
      Note that, in the above, if we
    </p>
    <p>
      The idea is that self.x first looks into the instance for the attribute
      x, and when that fails, it looks into the class itself.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      Now we can use the class <code>ComplexNumber</code> defined above to
      create an object:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = ComplexNumber(2,3)</pre>
    <p>
      Class instantiation uses function notation with the class name serving
      as a function name. The returned value is a new instance of the class.
    </p>
    <p>
      If there is a method named <code>__init__</code>, which is ture for the
      example shown above, it will be used by python as a constructor, which
      means this method is automatically called when we create an instance of
      the class.
    </p>
    <p>
      When the method is called, users must omit the object name from the
      argument list, and the name is figured out and inserted to the argument
      list by python behind the scene.
    </p>
    <p>
      Class functions that begin with double underscore __ are called special
      functions as they have special meaning. Of one particular interest is
      the __init__() function. This special function gets called whenever a
      new object of that class is instantiated. This type of function is also
      called constructors in Object Oriented Programming (OOP). We normally
      use it to initialize all the variables.
    </p>
    <p>
      Next, examine the instance we created above:
    </p>
    <pre class="verbatim" xml:space="preserve">
a.show() #the object a is implitcitly provided as the first argument
print(a.real)</pre>
    <p>
      In Python, attributes may be referenced/created by methods as well as by
      users of an object. There are no &ldquo;private&rdquo; instance
      variables (variables that can only be accessed within methods of an
      object). In other words, it is imposible to enforce data hiding in
      python &mdash; it is all based upon convention. The convention (followed
      by most Python code) is: a name prefixed with an underscore (e.g. _spam)
      should be treated as a non-public part of the API (whether it is a
      method or a data member).
    </p>
    <p>
      Note that clients may add data attributes of their own to an instance
      object. As long as name conflicts are avoided, adding new data
      abttributs does not affect the validity of the methods.
    </p>
    <p>
      
    </p>
    <p>
      The global scope associated with a method is the module containing its
      definition. (A class is never used as a global scope.) While one rarely
      encounters a good reason for using global data in a method, there are
      many legitimate uses of the global scope: functions and modules imported
      into the global scope can be used by methods. 
    </p>
    <p>
      class attribute vs. instance attribute
    </p>
    <p>
      Attributes of an object can be created on the fly.
    </p>
    <p>
      
    </p>
    <p>
      Any method we create in a class will automatically be created as an
      instance method. We must explicitly tell Python that it is a class
      method or static method.
    </p>
    <p>
      Use the @classmethod decorator or the classmethod() function to define
      the class method
    </p>
    <p>
      Use the @staticmethod decorator or the staticmethod() function to define
      a static method.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      we'll find some good reasons why a method would want to reference its
      own class.
    </p>
    <p>
      A language feature would not be worthy of the name &ldquo;class&rdquo;
      if it does not support inheritance.
    </p>
    <p>
      Finally, notice that the class .__dict__ and the instance .__dict__ are
      totally different and independent dictionaries. That's why class
      attributes are available immediately after you run or import the module
      in which the class was defined. In contrast, instance attributes come to
      life only after an object or instance is created.
    </p>
    <p>
      
    </p>
    <p>
      The scope of names defined in a class block is limited to the class
      block; it does not extend to the code blocks of methods.
    </p>
    <p>
      
    </p>
    <p>
      In general, when you're writing object-oriented code in Python and you
      try to access an attribute, your program takes the following steps:
    </p>
    <p>
      
    </p>
    <p>
      Check the instance local scope or namespace first.
    </p>
    <p>
      If the attribute is not found there, then check the class local scope or
      namespace.
    </p>
    <p>
      If the name doesn't exist in the class namespace either, then you'll get
      an AttributeError.
    </p>
    <p>
      Although classes define a class local scope or namespace, they don't
      create an enclosing scope for methods.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      Classes themselves are objects (class objects), which means that a class
      name can be rebound to new names. This makes importing easy, where we
      can rename a class name to a new simple name.
    </p>
    <p>
      Most built-in operators with special syntax (arithmetic operators,
      subscripting etc.) can be redefined for class instances.
    </p>
    <p>
      
    </p>
    <p>
      Python Iterators
    </p>
    <p>
      An iterator is an object that contains a countable number of values and
      can be iterated upon, meaning that we can traverse through all the
      values. Technically, in Python, an iterator is an object which
      implements the iterator protocol, which consist of the methods
      <code>__iter__()</code> and <code>__next__()</code>. The
      <code>for</code> loop actually creates an iterator object and executes
      the <code>next()</code> method for each loop.
    </p>
    <p>
      
    </p>
    <h2 id="auto-24">8<span style="margin-left: 1em"></span>Built-in data structure<span style="margin-left: 1em"></span></h2>
    <p>
      Python has four primitive data structures, namely list, tuple, set, and
      dict:
    </p>
    <pre class="verbatim" xml:space="preserve">
L = [3, &quot;hello&quot;, 0.5] # list
t = (1,2,&quot;apple&quot;,3) # tuple
t =  1,2, &quot;apple&quot;,3  # tuple
s = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} #set
d = {&quot;a&quot;:1, &quot;b&quot;:2} #dict,each element has two filds, key and value, separated by :</pre>
    <p>
      Examining the above codes, we can summarize the sytax for differnt data
      structure: (1) elements in the four data structures are all separated by
      commas; (2) lists are written with <strong>square-brackets</strong>,
      tuples are written with optional <strong>round-brackets</strong>, sets
      and dicts are written with <strong>curly-brackets</strong>; (3) a dict
      (or hash) is a special set in which each element has two fields, key and
      value, which are separated by a colon.
    </p>
    <p>
      Lists and tuples are <strong>ordered</strong> collections and thus
      support <strong>indexing</strong> whereas sets and dicts are
      <strong>unordered</strong> and do not support indexing. The difference
      between a list and a tuple lies in that a list can be modfied but a
      tuple is unchangable.
    </p>
    <p>
      The primitive type <code>string</code> can also be considered a
      nontrivial data structure, which supports indexing, similar to a list.
    </p>
    <p>
      Lists, tuples, and strings are subscriptable, but sets are not.
      Attempting to access an element of an object that isn't subscriptable
      will raise a TypeError.
    </p>
    <p>
      An object is mutable if its structure can be changed in place rather
      than requiring reassignment:
    </p>
    <p>
      Lists and sets are mutable, as are dictionaries and other mapping types.
      Strings and tuples are not mutable. Attempting to modify an element of
      an immutable object will raise a TypeError.
    </p>
    <p>
      
    </p>
    <h3 id="auto-25">8.1<span style="margin-left: 1em"></span>List<span style="margin-left: 1em"></span></h3>
    <p>
      One of the most fundamental data structures in any language is the
      array. Python does not have a native array data structure, but it has
      the list data structure which is more general: a list in Python can
      contain items of various types. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
myList = [3, &quot;hello&quot;, 0.5] #define a list containing three items of different types</pre>
    <p>
      Since a list contains misc items, which are not just numbers, some
      operations on lists are different from array operations that we expect
      in an array Language. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [12]: a=[1,2,3]
In [13]: 2*a
Out[13]: [1, 2, 3, 1, 2, 3] #rather than doubling each element vale in the list</pre>
    <p>
      Adding lists concatenates them, just as the &ldquo;<tt>+</tt>&rdquo;
      operator concatenates strings. To use the standard array operation, we
      can use <code>numpy.asarray</code> to convert a list to an array:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [16]: b=np.asarray(a)
In [17]: 2*b
Out[17]: array([2, 4, 6])</pre>
    <p>
      The Python standard library defines an array type, which is still a list
      type, except that the type of objects stored in it is constrained to a
      single type. The methods of this array type are different from the usual
      array operation. For example, <code>2*a</code> is not to double the
      value of the each element in the array:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [1]: import array
In [2]: a=array.array('d', [1,2])
In [3]: 2*a
Out[3]: array('d', [1.0, 2.0, 1.0, 2.0])</pre>
    <p>
      As a result, this array type is not as versatile, efficient, or useful
      as the NumPy array. I will not be using Python arrays at all. Therefore,
      whenever I refer to an &ldquo;array,&rdquo; I mean a &ldquo;NumPy
      array.&rdquo;
    </p>
    <pre class="verbatim" xml:space="preserve">
In [1]: import numpy as np
In [2]: a=[1,2,3]
In [3]: b=np.array(a)
In [4]: b
Out[4]: array([1, 2, 3])
In [5]: 2*b
Out[5]: array([2, 4, 6])</pre>
    <h4 id="auto-26">8.1.1<span style="margin-left: 1em"></span>Addressing and Slicing lists<span style="margin-left: 1em"></span></h4>
    <p>
      List elements can be accessed by using indexes. Indexes of a list start
      from zero, i.e., <code>myList[0]</code> corresponds to the first item in
      the list. Elements of a list can also be accessed by using negative
      index. For example <code>myList[-1]</code> refers to the last element of
      the list, and <code>myList[-2]</code> refers to the next-to-last element
      of the list, etc.
    </p>
    <p>
      We can use slicing notation to pick out a sublist, e.g., <code>b =
      myList[0:2]</code>. Python use the convention that the final element
      specified, i.e. <code>myList[2]</code> in this case, is not included in
      a list slice. If the upper and/or lower limit are omitted, the
      corresponding list limit will be used, e.g., <code>myList[:]</code>
      refers to the whole list.
    </p>
    <p>
      Nested lists (multidimensional lists, lists of lists) can be referenced
      by using multiply index, such as <code>myList[0][1]</code>, not
      <code>myList[0,1]</code>. The latter notation only works for
      <code>numpy</code> array objects.
    </p>
    <p>
      
    </p>
    <h4 id="auto-27">8.1.2<span style="margin-left: 1em"></span>List methods<span style="margin-left: 1em"></span></h4>
    <p>
      Python is an object-orientated language, and as such it uses classes to
      define data types, including its primitive types. A list object has some
      predefined methods. These methods are invoked in the same way as in
      other object-orientated Languages, i.e.,
      <code>instant.method(arg1,arg2,&hellip;)</code>. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
mylist.append('d') #will add 'd' to the list
mylist.pop(2) # will remove items by position (index), remove the 3rd item
mylist.remove(x) # Remove the first item from the list whose value is x.
mylist.index(x) #return the index of the first item whose value is x
mylist.count(x) # Return the number of times x appears in the list.
list.insert(i, x) #will insert an item before element with index i.</pre>
    <p>
      We can view all the methods defined for a object by using the built-in
      function <code>dir</code>. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
L = [] # define a list object
dir(L) # view all the methods of the list object</pre>
    <h3 id="auto-28">8.2<span style="margin-left: 1em"></span>List Comprehensions<span style="margin-left: 1em"></span></h3>
    <p>
      A list comprehension consists of brackets containing an expression
      followed by a <code>for</code> clause, then zero or more
      <code>for</code> or <code>if</code> clauses. The result will be a new
      list resulting from evaluating the expression in the context of the
      <code>for</code> and <code>if</code> clauses. For example,
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; ls = [1, 2, -3, -4]
&gt;&gt;&gt; [math.sqrt(x) for x in ls if x&gt;0]
[1.0, 1.414]</pre>
    <p>
      The following code combines the elements of two lists if they are not
      equal:
    </p>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt; [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</pre>
    <p>
      List comprehensions are also more declarative than loops, which means
      they're easier to read and understand. Loops require you to focus on how
      the list is created. You have to manually create an empty list, loop
      over the elements, and add each of them to the end of the list. With a
      list comprehension in Python, you can instead focus on what you want to
      go in the list and trust that Python will take care of how the list
      construction takes place.
    </p>
    <p>
      
    </p>
    <h3 id="auto-29">8.3<span style="margin-left: 1em"></span>String and string methods<span style="margin-left: 1em"></span></h3>
    <p>
      Single or double quotation marks are used to define a string value:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [17]: a = 'hello, world' # string
In [18]: a = &quot;hello, world&quot; # string</pre>
    <p>
      Each character in a string corresponds to an index and can be accessed
      using index notation (similar to a list):
    </p>
    <pre class="verbatim" xml:space="preserve">
In [19]: a[0]
Out[19]: 'h'
In [21]: a[0:6]
Out[21]: 'hello,'</pre>
    <p>
      String methods:
    </p>
    <pre class="verbatim" xml:space="preserve">
a = &quot;hello, world&quot; # string
a.split(&quot;,&quot;)  #Splits the string at the specified separator, and returns a list
a.find(&quot;o&quot;) #Searches the string for &quot;o&quot; and returns the position where it was found</pre>
    <p>
      Again, we can view all the methods defined for <code>string</code>
      object by using the built-in function <code>dir</code>. Or search
      &ldquo;python string methods&rdquo; online to find useful methods of
      string objects. Note that all string methods returns new values. They do
      not change the original string.
    </p>
    <h3 id="auto-30">8.4<span style="margin-left: 1em"></span>Tuple<span style="margin-left: 1em"></span></h3>
    <p>
      Another data structure similar to list is tuple, which is an ordered
      collection of items enclosed in round-brackets (parentheses):
    </p>
    <pre class="verbatim" xml:space="preserve">
t=(1,2,&quot;apple&quot;)</pre>
    <p>
      The round-brackets are optional.
    </p>
    <p>
      Slicing and addressing a tuple are similar to those of a list. Like a
      list, we can loop through the tuple items by using a <code>for</code>
      loop. Unlike a list,  Tuples are <strong>unchangeable</strong>. Once a
      tuple is created, we cannot change its values.
    </p>
    <h4 id="auto-31">8.4.1<span style="margin-left: 1em"></span>Tuple methods<span style="margin-left: 1em"></span></h4>
    <pre class="verbatim" xml:space="preserve">
mytuble.count(&quot;apple&quot;) # Returns the number of times a specified value occurs in a tuple
mytuble.index(&quot;apple&quot;) # Searches the tuple for a specified value and returns the index</pre>
    <h3 id="auto-32">8.5<span style="margin-left: 1em"></span>Set<span style="margin-left: 1em"></span></h3>
    <pre class="verbatim" xml:space="preserve">
a={&quot;dd&quot;, 1, (3,4)} #an items in set can be a tuple, but can not be a list</pre>
    <p>
      A set itself may be modified, but the elements contained in the set must
      be of an immutable type. Therefore a list can not be an element of a
      set.
    </p>
    <p>
      Set items are unordered, unindexed, and do not allow duplicate values.
      Set items are unchangeable, but you can remove items and add new items.
    </p>
    <h4 id="auto-33">8.5.1<span style="margin-left: 1em"></span>Access items in a set<span style="margin-left: 1em"></span></h4>
    <p>
      We can not access an item in a set by referring to an index, since sets
      are unordered and have no index:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [7]: a={&quot;dd&quot;, 1}
In [8]: a[1]
TypeError: 'set' object does not support indexing</pre>
    <p>
      But we can loop through a set using <code>for</code> loop, or ask if a
      specified value is present in a set by using the <code>in</code>
      keyword.
    </p>
    <pre class="verbatim" xml:space="preserve">
myset = {&quot;apple&quot;, &lsquo;&lsquo;banana&quot;, &lsquo;&lsquo;cherry&quot;}
print(&quot;banana&quot; in myset) #True
for x in myset:
    print(x)</pre>
    <h4 id="auto-34">8.5.2<span style="margin-left: 1em"></span>Set methods<span style="margin-left: 1em"></span></h4>
    <pre class="verbatim" xml:space="preserve">
myset.add(&quot;apple&quot;) # adds an element to the set
myset.remove(&quot;apple&quot;) # removes a particular element from the set
myset.pop() # removes an random element from the set, retuns the removed item</pre>
    <h4 id="auto-35">8.5.3<span style="margin-left: 1em"></span>Set comprehension<span style="margin-left: 1em"></span></h4>
    <pre class="verbatim" xml:space="preserve">
&gt;&gt;&gt;s = {v for v in 'abcdabcd' if v not in 'cb'}
&gt;&gt;&gt; print(s)
{'a', 'd'}</pre>
    <p>
      In <code>Racket</code>, the above set comprehension is written as
    </p>
    <pre class="verbatim" xml:space="preserve">
(for/set ([v &quot;ABCDABCD&quot;] #:unless (member v (string-&gt;list &quot;CB&quot;))) v )</pre>
    <h3 id="auto-36">8.6<span style="margin-left: 1em"></span>Dictionary<span style="margin-left: 1em"></span></h3>
    <p>
      A dictionary is a collection of a pair of items enclosed in curly
      brackets:
    </p>
    <pre class="verbatim" xml:space="preserve">
d={&quot;a&quot;:1, &quot;b&quot;:2} #each element has two filds, key and value, separated by :</pre>
    <p>
      In other languages, data types similar to Python dictionaries may be
      called &ldquo;hashmaps&rdquo; or &ldquo;associative arrays&rdquo;.
    </p>
    <p>
      Dictionaries can be built up and added to in a straightforward manner:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [8]: d = {}
In [9]: d[&quot;last name&quot;] = &lsquo;&lsquo;Alberts&quot;
In [10]: d[&quot;first name&quot;] = &lsquo;&lsquo;Marie&quot;
In [11]: d[&quot;birthday&quot;] = &lsquo;&lsquo;January 27&quot;
In [12]: d
Out[12]: {'birthday': 'January 27', 'first name': 'Marie','last name': 'Alberts'}        </pre>
    <p>
      The type of keys of a dictionary can be string, int, float, and even a
      tuple. For example:
    </p>
    <pre class="verbatim" xml:space="preserve">
In [15]: A={(1,2):4, &quot;b&quot;:5}
In [16]: A[(1,2)]
Out[16]: 4</pre>
    <p>
      It is interesting to note that referencing a dictionary item is very
      similar to referencing a list element if the keys are of int type.
    </p>
    <h4 id="auto-37">8.6.1<span style="margin-left: 1em"></span>Dictionary methods<span style="margin-left: 1em"></span></h4>
    <pre class="verbatim" xml:space="preserve">
d={&quot;a&quot;:1, &quot;b&quot;:2}
d.keys() # return all the keys of a dictionary
d.values() # return all the values of a dictionary</pre>
    <p>
      The following is a summary of useage of various brackets in python:
    </p>
    <ul>
      <li>
        <p>
          square brackets <code>[]</code> are used in defining lists, list
          comprehensions, and for retriving elements from lists/tuple/dicts,
          where retriving can be indexing/slicing/lookup. In numpy, 
          <code>[]</code> are used for arrays.
        </p>
      </li>
      <li>
        <p>
          round brackets <code>()</code> are basically used to group things.
          Specifically, <code>()</code> are used in function definitions/calls
          to gather arguments, generator expressions, defining order of
          operations, and tuples, where <code>()</code> can be omitted if
          there is no ambiguity.
        </p>
      </li>
      <li>
        <p>
          curly brackets <code>{}</code> are used in defining the two hash
          table types&ndash; dictionaries and sets.
        </p>
      </li>
    </ul>
    <h2 id="auto-38">9<span style="margin-left: 1em"></span>File Handling<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-39">9.1<span style="margin-left: 1em"></span>Create file object<span style="margin-left: 1em"></span></h3>
    <p>
      Python builtin function <code>open()</code> takes two parameters;
      <em>filename</em>, and <em>mode</em>, and returns a file object. For
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
f = open('t.txt', 'r')</pre>
    <p>
      There are four different modes for opening a file:
    </p>
    <p>
      <code>&quot;r&quot;</code> - Read - Default value. Opens a file for
      reading, error if the file does not exist
    </p>
    <p>
      <code>&quot;a&quot;</code> - Append - Opens a file for appending,
      creates the file if it does not exist
    </p>
    <p>
      <code>&quot;w&quot;</code> - Write - Opens a file for writing, creates
      the file if it does not exist
    </p>
    <p>
      <code>&quot;x&quot;</code> - Create - Creates the specified file,
      returns an error if the file exists
    </p>
    <p>
      In addition you can specify if the file should be handled as binary or
      text mode
    </p>
    <p>
      <code>&quot;t&quot;</code> - Text - Default value. Text mode
    </p>
    <p>
      <code>&quot;b&quot;</code> - Binary - Binary mode (e.g. images)
    </p>
    <h3 id="auto-40">9.2<span style="margin-left: 1em"></span>Methods of file object<span style="margin-left: 1em"></span></h3>
    <p>
      A python file object has several predefined methods, such as
      <code>read</code>, <code>readline</code>, <code>readlines</code>. For
      example:
    </p>
    <pre class="verbatim" xml:space="preserve">
f = open('t.txt', 'r')
txt = f.read() #readin the entire file, return a string
f.close() 
f = open('t.txt', 'r')
txt1 = f.readline() #readin one line from the file, return a string
txt2 = f.readline() #readin another line from the file
f.close()
f = open('t.txt', 'r')
txt = f.readlines() #read the entire file, return a list of string (one string=&gt;one line)</pre>
    <p>
      A file object can also be converted to a list:
    </p>
    <pre class="verbatim" xml:space="preserve">
f = open('t.txt', 'r')
a = list(f) # return a list, the same as a = f.readlines()</pre>
    <p>
      A python file object is also an iterator, which means that we can loop
      over the file object:
    </p>
    <pre class="verbatim" xml:space="preserve">
f=open('t.txt', 'r')
for line in f:
    print(line, end='')</pre>
    <h2 id="auto-41">10<span style="margin-left: 1em"></span>Numpy and matplotlib<span style="margin-left: 1em"></span></h2>
    <p>
      NumPy is the reason why Python stands among the ranks of R, Matlab, and
      Julia, as one of the most popular languages for doing STEM-related
      computing. It is a third-party library (i.e. it is not part of Python's
      standard library) that facilitates numerical computing in Python by
      providing users with a versatile N-dimensional array object for storing
      data, and powerful mathematical functions for operating on those arrays
      of numbers. NumPy makes use of a process known as vectorization, that
      enables a degree of computational efficiency that is otherwise
      unachievable by the Python language.
    </p>
    <p>
      The impact that NumPy has had on the landscape of numerical computing in
      Python is hard to overstate. Whether you are plotting data in
      matplotlib, analyzing tabular data via pandas and xarray, using OpenCV
      for image and video processing, doing astrophysics research with the
      help of astropy, or trying out machine learning with Scikit-Learn and
      MyGrad, you are using Python libraries that bare the indelible mark of
      NumPy. At their core, each of these libraries depend on NumPy's
      N-dimensional array and its efficient vectorization capabilities. NumPy
      also fundamentally impacts the designs of these libraries and the way
      that they interface with their users. Thus, one cannot leverage these
      tools effectively, and cannot do STEM work in Python in general, without
      having a solid foundation in NumPy.
    </p>
    <h3 id="auto-42">10.1<span style="margin-left: 1em"></span>Numpy array<span style="margin-left: 1em"></span></h3>
    <p>
      NumPy is used to work with arrays. The array object in NumPy is called
      <code>ndarray</code>. The data of a NumPy array are stored in contiguous
      block of system memory. This is the main difference between an array and
      a pure Python structure, such as a list, where the items are scattered
      across the system memory. This aspect is the critical feature that makes
      NumPy arrays efficient.
    </p>
    <p>
      We can create a NumPy ndarray object by using various functions, such
      as<code> np.array()</code> and <code>np.zeros()</code>.
    </p>
    <p>
      <code>ndarray.tolist()</code> Return a copy of the array data as a
      (nested) Python list.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <pre class="verbatim" xml:space="preserve">
x=np.array([1,2,3,4])
y=np.array([5,6,7])
XX, YY = np.meshgrid(x,y)</pre>
    <div style="margin-top: 1em; margin-bottom: 1em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><img class="image" src="meshgrid.png" width="70%"></img></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><div class="caption">
            <font style="font-size: 84.1%"><p>
              <b>Figure 1. </b><a id="auto-43"></a>
            </p></font>
          </div></td>
        </tr></tbody>
      </table>
    </div>
    <p>
      
    </p>
    <p>
      &ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;&ndash;
    </p>
    <p>
      Practically all software has some bugs; it's a matter of frequency and
      severity rather than absolute perfection. When a bug does occur, you
      want to spend the minimum amount of time getting from the observed
      symptom to the root cause.
    </p>
    <p>
      While a CPU-bound task is characterized by the computer's cores
      continually working hard from start to finish, an IO-bound job is
      dominated by a lot of waiting on input/output to complete.
    </p>
    <p>
      non-blocking function
    </p>
    <p>
      Over the last few years, a separate design has been more comprehensively
      built into CPython: asynchronous IO, enabled through the standard
      library's asyncio package and the new async and await language keywords.
      (async IO is not a newly invented concept, and it has existed or is
      being built into other languages and runtime environments, such as Go,
      C#, or Scala.)
    </p>
    <p>
      Async IO is not threading, nor is it multiprocessing. It is not built on
      top of either of these. In fact, async IO is a single-threaded,
      single-process design: it uses cooperative multitasking.
    </p>
    <p>
      All Python (intepretor) releases are open source. Python works on many
      platforms (e.g. Linux, Windows, Mac). Python has lots of libraries,
      documentation, and an active community. 
    </p>
    <p>
      
    </p>
    <p>
      &ndash;&ndash;&ndash;&ndash;-
    </p>
    <p>
      When developing this document, I read the following materials:
    </p>
    <p>
      https://docs.python.org/
    </p>
    <p>
      https://www.w3schools.com/python/
    </p>
    <p>
      https://physics.nyu.edu/pine/pymanual/html/
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
  </body>
</html>